<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UT-Visualizer Pro (Manual Edition v37)</title>
    <style>
        :root { --bg-color: #1a1a1a; --panel-color: #262626; --accent-color: #00ff41; --text-color: #e0e0e0; --grid-color: rgba(0, 255, 65, 0.05); --fail-color: #ff3e3e; }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Courier New', Courier, monospace; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow-x: hidden; }
        header { padding: 12px 20px; border-bottom: 2px solid var(--accent-color); background-color: #000; display: flex; justify-content: space-between; align-items: center; }
        .main-container { display: flex; flex: 1; overflow: hidden; flex-direction: row; width: 100%; }
        .canvas-area { flex: 2; position: relative; background-color: #111; background-image: linear-gradient(var(--grid-color) 1px, transparent 1px), linear-gradient(90deg, var(--grid-color) 1px, transparent 1px); background-size: 20px 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; overflow: hidden; }
        canvas { background-color: transparent; max-width: 100%; height: auto; }
        #statusOverlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: var(--accent-color); font-weight: bold; font-size: 1.2rem; text-shadow: 0 0 10px rgba(0, 255, 65, 0.5); background-color: rgba(0,0,0,0.8); padding: 5px 15px; border: 1px dashed var(--accent-color); }
        #judgeOverlay { position: absolute; top: 20px; right: 20px; font-weight: bold; font-size: 1.2rem; background-color: rgba(0,0,0,0.8); padding: 10px 20px; border: 2px solid #555; border-radius: 5px; text-align: right; }
        .input-panel { flex: 1; min-width: 380px; max-width: 480px; background-color: var(--panel-color); padding: 15px 20px; border-left: 2px solid var(--accent-color); overflow-y: auto; display: flex; flex-direction: column; gap: 8px; box-sizing: border-box; }
        .input-group { margin-bottom: 2px; }
        .input-group label { display: block; font-size: 0.75rem; color: var(--accent-color); margin-bottom: 2px; white-space: nowrap; }
        .input-group input, .input-group select { width: 100%; background: #000; border: 1px solid #444; color: #fff; padding: 6px 8px; font-size: 0.95rem; box-sizing: border-box; font-family: 'Courier New', monospace; }
        .input-group input:focus, .input-group select:focus { border-color: var(--accent-color); outline: none; }
        input[readonly] { color: #888; border-color: #222; }
        .flaw-estimation { border: 1px dashed #ff9900; padding: 8px; background: rgba(255,153,0,0.1); margin-top: 4px; }
        .flaw-estimation label { color: #ff9900; font-size: 0.8rem; font-weight: bold; }
        .flaw-estimation div { font-weight: bold; color: #fff; font-size: 0.95rem; margin-top: 2px; }
        
        .record-section { margin-top: 5px; border-top: 2px dashed #444; padding-top: 8px; }
        .record-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .btn { background: #333; color: #fff; border: 1px solid var(--accent-color); padding: 5px 10px; cursor: pointer; font-weight: bold; transition: 0.2s; }
        .btn:hover { background: var(--accent-color); color: #000; }
        .btn-record { background: rgba(0, 255, 65, 0.2); width: 100%; padding: 12px; font-size: 1rem; margin-top: 5px; border-radius: 4px; }
        .btn-reset { border-color: var(--fail-color); color: var(--fail-color); padding: 4px 8px; font-size: 0.8rem; }
        .btn-reset:hover { background: var(--fail-color); color: #fff; }
        .record-list { max-height: 150px; overflow-y: auto; background: #111; border: 1px solid #444; padding: 5px; font-size: 0.85rem; }
        .record-item { display: flex; flex-direction: column; padding: 6px; border-bottom: 1px solid #333; }
        .record-item:last-child { border-bottom: none; }
        .record-item-top { display: flex; justify-content: space-between; color: var(--accent-color); font-weight: bold; margin-bottom: 2px; }
        .record-item-bottom { display: flex; justify-content: space-between; color: #aaa; font-size: 0.75rem; }
        .sum-result { margin-top: 8px; padding: 10px; background: #000; border: 2px solid #555; text-align: center; font-size: 1.05rem; font-weight: bold; line-height: 1.4; }
        .flex-row { display: flex; gap: 6px; }
        .flex-1 { flex: 1; min-width: 0; } /* min-width:0 prevents flex items from overflowing */
        
        /* ã‚¹ãƒãƒ›ç”¨ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–è¨­è¨ˆ (å¹…768pxä»¥ä¸‹ã§é©ç”¨) */
        @media (max-width: 768px) { 
            .main-container { flex-direction: column; } 
            .canvas-area { min-height: 250px; width: 100%; } 
            .input-panel { min-width: 100%; width: 100%; max-width: none; border-left: none; border-top: 2px solid var(--accent-color); padding: 10px 15px; } 
            .input-group label { font-size: 0.7rem; }
            .input-group input, .input-group select { font-size: 1rem; padding: 8px 4px; } /* ã‚¹ãƒãƒ›ã§ã‚¿ãƒƒãƒ—ã—ã‚„ã™ã„ã‚ˆã†ã«èª¿æ•´ */
            .flex-row { gap: 4px; }
            #judgeOverlay { font-size: 1rem; padding: 6px 12px; }
            #statusOverlay { font-size: 1rem; bottom: 10px; }
        }
    </style>
</head>
<body>

<header>
    <div style="font-weight: bold; letter-spacing: 1px;">UT-VISUALIZER // MANUAL_v37</div>
    <div style="font-size: 0.8rem; opacity: 0.7;">è£½ä½œè€… æ¯”å˜‰</div>
</header>

<div class="main-container">
    <div class="canvas-area">
        <canvas id="utCanvas" width="800" height="400"></canvas>
        <div id="statusOverlay">READY</div>
        <div id="judgeOverlay" style="color:#aaa;">
            <div style="font-size:0.75rem; color:#fff;">ã€å˜ä¸€ã‚­ã‚ºè©•ä¾¡ã€‘</div>
            <div id="singleJudgeText">å¾…æ©Ÿä¸­</div>
        </div>
    </div>

    <div class="input-panel" id="inputs">
        <div class="flex-row">
            <div class="input-group flex-1">
                <label>æ¿åš T (mm)</label>
                <select id="thickness">
                    <option value="9">9</option><option value="12">12</option>
                    <option value="16">16</option><option value="19" selected>19</option>
                    <option value="22">22</option><option value="25">25</option>
                    <option value="32">32</option><option value="50">50</option>
                </select>
            </div>
            <div class="input-group flex-1">
                <label>æº¶æ¥é•·ã• (mm)</label>
                <input type="number" id="weldLength" value="300" step="10">
            </div>
            <div class="input-group flex-1">
                <label>ä½™ç››ã‚Š (mm)</label>
                <input type="number" id="reinf" value="2.0" step="0.5">
            </div>
        </div>
        
        <div class="flex-row">
            <div class="input-group flex-1">
                <label>é–‹å…ˆå½¢çŠ¶</label>
                <select id="jointShape">
                    <option value="single_bevel" selected>ãƒ¬å½¢ (ç‰‡å´)</option>
                    <option value="v_groove">Vå½¢ (ä¸¡å´)</option>
                    <option value="k_groove">Kå½¢ (ä¸¡é¢)</option>
                    <option value="x_groove">Xå½¢ (ä¸¡é¢)</option>
                </select>
            </div>
            <div class="input-group flex-1" style="flex:0.6;">
                <label>ã‚®ãƒ£ãƒƒãƒ—</label>
                <input type="number" id="rootGap" value="7.0" step="1.0">
            </div>
            <div class="input-group flex-1" style="flex:0.6;">
                <label>å±ˆæŠ˜è§’ Î¸</label>
                <input type="number" id="angle" value="70.0" step="0.1">
            </div>
        </div>

        <div style="border-top: 1px solid #444; margin: 4px 0;"></div>

        <div class="flex-row">
            <div class="input-group flex-1">
                <label>æ¢è§¦å­ Y (mm)</label>
                <input type="number" id="probePos" value="0.0" step="0.5">
            </div>
            <div class="input-group flex-1">
                <label>è·¯ç¨‹ W (mm)</label>
                <input type="number" id="beamPath" value="0.0" step="0.1" style="font-weight:bold; color:#fff; background:#222; border: 2px solid var(--accent-color);">
            </div>
        </div>

        <div class="flex-row">
            <div class="input-group flex-1">
                <label>æ·±ã• d (mm)</label>
                <input type="number" id="depth" value="-" readonly>
            </div>
            <div class="input-group flex-1">
                <label>ä½ç½® K (mm)</label>
                <input type="number" id="k_value" value="-" readonly style="color:var(--accent-color); font-weight:bold;">
            </div>
        </div>

        <div class="flaw-estimation">
            <label>ğŸ¤– æ¬ é™¥æ¨å®š (AI)</label>
            <div id="flawType">-</div>
        </div>
        
        <div style="border-top: 1px solid #444; margin: 4px 0;"></div>

        <div style="font-size: 0.85rem; color: #ff9900; font-weight: bold; margin-bottom: 2px;">ã€ è¨˜éŒ²ï¼†è‡ªå‹•ç·å’Œåˆ¤å®š ã€‘</div>
        <div class="flex-row">
            <div class="input-group flex-1">
                <label>Xä½ç½® (mm)</label>
                <input type="number" id="flawX" value="0.0" step="1.0">
            </div>
            <div class="input-group flex-1" style="flex: 0.6;">
                <label>é ˜åŸŸ</label>
                <select id="region">
                    <option value="I" selected>â… </option><option value="II">â…¡</option>
                    <option value="III">â…¢</option><option value="IV">â…£</option><option value="V">â…¤</option>
                </select>
            </div>
            <div class="input-group flex-1" style="flex: 0.8;">
                <label>é•·ã• L (mm)</label>
                <input type="number" id="flawLength" value="0.0" step="1.0">
            </div>
        </div>
        
        <button class="btn btn-record" onclick="recordCurrentFlaw()">ï¼‹ ã“ã®ä½ç½®ã®ã‚­ã‚ºã‚’è¨˜éŒ²</button>

        <div class="record-section">
            <div class="record-header">
                <span style="color: var(--accent-color); font-weight: bold; font-size: 0.9rem;">ğŸ“‹ é‡å¸³ãƒ‡ãƒ¼ã‚¿ (Noé€£ç•ª)</span>
                <button class="btn btn-reset" onclick="resetRecords()">å…¨æ¶ˆå»</button>
            </div>
            <div class="record-list" id="recordList">
                <div style="color: #666; text-align: center; padding: 10px;">è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</div>
            </div>
            <div class="sum-result" id="sumResult">
                <div style="font-size: 0.8rem; color: #aaa;">ç·å’Œåˆ¤å®š (å¢ƒç•Œå€¤: - mm)</div>
                <span style="color: #fff;">ç·å’Œ: 0.0 mm</span>
            </div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('utCanvas');
    const ctx = canvas.getContext('2d');
    const statusOverlay = document.getElementById('statusOverlay');
    const judgeOverlay = document.getElementById('judgeOverlay');
    const singleJudgeText = document.getElementById('singleJudgeText');
    const flawTypeDisplay = document.getElementById('flawType');
    
    let recordedFlaws = [];
    let flawCounter = 0;
    const regionScores = { "I": 1, "II": 2, "III": 3, "IV": 4, "V": 5 };
    const regionNames = ["", "â… ", "â…¡", "â…¢", "â…£", "â…¤"];

    const inputs = document.querySelectorAll('#inputs input, #inputs select');
    inputs.forEach(input => {
        ['input', 'change', 'keyup'].forEach(ev => input.addEventListener(ev, draw));
    });

    function getLimits(t) {
        if (t >= 6 && t <= 20) return { S: 10, M: 15, ML: 20, L: 30, LL: 40, ignore: 5 };
        if (t > 20 && t <= 48) return { S: t/2, M: t*0.75, ML: t, L: t*1.5, LL: t*2, ignore: t/4 };
        if (t > 48) return { S: 24, M: 36, ML: 48, L: 72, LL: 96, ignore: 12 };
        return { S: 0, M: 0, ML: 0, L: 0, LL: 0, ignore: 0 };
    }

    function evaluateSingle(region, length, limits) {
        if (length < limits.ignore) return { result: "è©•ä¾¡å¤– (ç„¡è¦–)", isPass: true };
        if (region === "I") return { result: "åˆ æ ¼", isPass: true };
        if (region === "II" && length >= limits.L) return { result: "ä¸åˆæ ¼ (Lä»¥ä¸Š)", isPass: false };
        if ((region === "III" || region === "IV") && length >= limits.ML) return { result: "ä¸åˆæ ¼ (MLä»¥ä¸Š)", isPass: false };
        if (region === "V" && length >= limits.M) return { result: "ä¸åˆæ ¼ (Mä»¥ä¸Š)", isPass: false };
        return { result: "åˆ æ ¼", isPass: true };
    }

    function updateSumEvaluation(t, wLen) {
        const sumBox = document.getElementById('sumResult');
        if (recordedFlaws.length === 0) {
            sumBox.innerHTML = `<div style="font-size: 0.8rem; color: #aaa;">ç·å’Œåˆ¤å®š</div><span style="color: #fff;">è¨˜éŒ²ãªã—</span>`;
            sumBox.style.borderColor = "#555";
            return;
        }

        const limits = getLimits(t);
        let sorted = [...recordedFlaws].sort((a,b) => a.x - b.x);
        let merged = [];
        
        for (let f of sorted) {
            if (f.length < limits.ignore) continue;
            let start = f.x; let end = f.x + f.length; let rScore = regionScores[f.region];
            
            if (merged.length === 0) {
                merged.push({ start: start, end: end, maxL: f.length, maxRegScore: rScore, nos: [f.no] });
            } else {
                let last = merged[merged.length - 1];
                let gap = start - last.end;
                let maxOriginalL = Math.max(last.maxL, f.length);
                
                if (gap <= maxOriginalL) {
                    last.end = Math.max(last.end, end);
                    last.maxL = Math.max(last.maxL, f.length);
                    last.maxRegScore = Math.max(last.maxRegScore, rScore);
                    last.nos.push(f.no);
                } else {
                    merged.push({ start: start, end: end, maxL: f.length, maxRegScore: rScore, nos: [f.no] });
                }
            }
        }

        if (merged.length === 0) {
            sumBox.innerHTML = `<div style="font-size: 0.8rem; color: #aaa;">ç·å’Œåˆ¤å®š</div><span style="color: #00ff41;">å…¨ã¦è¶³åˆ‡ã‚Š(è©•ä¾¡å¤–)ã®ãŸã‚åˆæ ¼</span>`;
            sumBox.style.borderColor = "#00ff41";
            return;
        }

        let mergeTexts = [];
        merged.forEach(m => {
            if (m.nos.length > 1) mergeTexts.push(`No.${m.nos.join('ã¨')}ã¯åŒä¸€æ¬ é™¥`);
        });
        let mergeStr = mergeTexts.length > 0 ? `<div style="color:#ff9900; font-size:0.8rem; margin-top:4px;">â€»${mergeTexts.join(', ')}</div>` : '';

        let windowSize = Math.min(wLen, 300);
        let maxSum = 0; let worstRegScore = 0;

        for (let i = 0; i < merged.length; i++) {
            let winStart = merged[i].start; let winEnd = winStart + windowSize;
            let currentSum = 0; let currentMaxReg = 0;
            
            for (let j = 0; j < merged.length; j++) {
                let m = merged[j];
                let overlapStart = Math.max(winStart, m.start);
                let overlapEnd = Math.min(winEnd, m.end);
                if (overlapEnd > overlapStart) {
                    currentSum += (overlapEnd - overlapStart);
                    currentMaxReg = Math.max(currentMaxReg, m.maxRegScore);
                }
            }
            if (currentSum > maxSum) { maxSum = currentSum; worstRegScore = currentMaxReg; }
        }

        let maxRegionStr = regionNames[worstRegScore] || "â… ";
        let sumLimit = 9999; let limitName = "-";
        if (worstRegScore === 2) { sumLimit = limits.LL; limitName = "LL"; }
        else if (worstRegScore === 3 || worstRegScore === 4) { sumLimit = limits.L; limitName = "L"; }
        else if (worstRegScore === 5) { sumLimit = limits.ML; limitName = "ML"; }

        const isPass = (worstRegScore === 1) || (maxSum < sumLimit);
        const color = isPass ? "#00ff41" : "#ff3e3e";
        const judgeStr = isPass ? "åˆæ ¼" : "ä¸åˆæ ¼";
        
        sumBox.style.borderColor = color;
        sumBox.innerHTML = `
            <div style="font-size: 0.75rem; color: #aaa;">æœ€æ‚ª${windowSize}mmåŒºé–“ (é ˜åŸŸ: ${maxRegionStr} / é™ç•Œ ${limitName}=${sumLimit}mm)</div>
            <span style="color: ${color};">è©•ä¾¡é•·ã•å’Œ: ${maxSum.toFixed(1)} mm <br><b>ã€ ${judgeStr} ã€‘</b></span>
            ${mergeStr}
        `;
    }

    function recordCurrentFlaw() {
        const x = parseFloat(document.getElementById('flawX').value);
        const y0 = document.getElementById('probePos').value;
        const w = document.getElementById('beamPath').value;
        const d = document.getElementById('depth').value;
        const k = document.getElementById('k_value').value;
        if (d === "-" || k === "-") { alert("Wã‚’å…¥åŠ›ã—ã¦ä½ç½®ã‚’ç¢ºå®šã—ã¦ãã ã•ã„"); return; }
        
        const region = document.getElementById('region').value;
        const length = parseFloat(document.getElementById('flawLength').value);
        const t = parseFloat(document.getElementById('thickness').value);
        const wLen = parseFloat(document.getElementById('weldLength').value);
        
        flawCounter++;
        recordedFlaws.push({ no: flawCounter, x: x, y0: y0, w: w, d: d, k: k, region: region, length: length });
        document.getElementById('flawX').value = (x + length + 10).toFixed(1);
        
        renderRecordList();
        updateSumEvaluation(t, wLen);
    }

    function resetRecords() {
        if(confirm("é‡å¸³ãƒ‡ãƒ¼ã‚¿ã‚’å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) {
            recordedFlaws = []; flawCounter = 0;
            renderRecordList();
            const t = parseFloat(document.getElementById('thickness').value);
            const wLen = parseFloat(document.getElementById('weldLength').value);
            updateSumEvaluation(t, wLen);
        }
    }

    function renderRecordList() {
        const listDiv = document.getElementById('recordList');
        if (recordedFlaws.length === 0) { listDiv.innerHTML = '<div style="color: #666; text-align: center; padding: 10px;">è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</div>'; return; }
        let html = "";
        let sorted = [...recordedFlaws].sort((a,b) => a.x - b.x);
        sorted.forEach((f) => {
            html += `<div class="record-item">
                <div class="record-item-top"><span>No.${f.no}</span><span>é ˜åŸŸ${regionNames[regionScores[f.region]]} L: ${f.length}</span></div>
                <div class="record-item-bottom"><span>X: ${f.x}</span><span>Y: ${f.y0}</span><span>W: ${f.w}</span><span>d: ${f.d}</span><span>K: ${f.k}</span></div>
            </div>`;
        });
        listDiv.innerHTML = html;
        listDiv.scrollTop = listDiv.scrollHeight;
    }

    function estimateFlawType(T, G, d, K, jointShape, isBacking) {
        if (d < 0) return "è¡¨é¢ä½™ç››ã‚Šã‹ã‚‰ã®åå°„ (éæ¬ é™¥)";
        if (d > T && !isBacking) return "è£æ³¢ãƒ»è£é¢ä½™ç››ã‚Šã‹ã‚‰ã®åå°„ (éæ¬ é™¥)";
        if (d > T + 0.5 && isBacking) return "è£å½“ã¦é‡‘å†…éƒ¨ (ã ã‚Œè¾¼ã¿ç­‰)";
        
        const tol = 2.0; const angleRad = 35 * (Math.PI / 180);
        const isDouble = (jointShape === 'k_groove' || jointShape === 'x_groove');
        
        if (jointShape === 'single_bevel') {
            if (Math.abs(d - T) < tol) return "ãƒ«ãƒ¼ãƒˆéƒ¨ (æº¶è¾¼ã¿ä¸è‰¯)";
            if (Math.abs(K) < tol) return "å‚ç›´é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)";
            const slopeK = G + (T - d) * Math.tan(angleRad);
            if (Math.abs(K - slopeK) < tol) return "æ–œã‚é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)";
        } else if (jointShape === 'v_groove') {
            if (Math.abs(d - T) < tol) return "ãƒ«ãƒ¼ãƒˆéƒ¨ (æº¶è¾¼ã¿ä¸è‰¯)";
            const slopeK = G/2 + (T - d) * Math.tan(angleRad);
            if (Math.abs(K - slopeK) < tol || Math.abs(K + slopeK) < tol) return "é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)";
        } else if (isDouble) {
            if (Math.abs(d - T/2) < tol) return "ãƒ«ãƒ¼ãƒˆéƒ¨ä¸­å¤® (æº¶è¾¼ã¿ä¸è‰¯)";
            const d_from_surface = (d < T/2) ? d : (T - d);
            let slopeK = 0;
            if (jointShape === 'k_groove') {
                slopeK = G + (T/2 - d_from_surface) * Math.tan(angleRad);
                if (Math.abs(K) < tol) return "å‚ç›´é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)";
            } else {
                slopeK = G/2 + (T/2 - d_from_surface) * Math.tan(angleRad);
            }
            if (Math.abs(K - slopeK) < tol || Math.abs(K + slopeK) < tol) {
                return (d < T/2) ? "ä¸Šå´é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)" : "ä¸‹å´é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)";
            }
        }
        return "æº¶æ¥é‡‘å±å†… (ãƒ–ãƒ­ãƒ¼ãƒ›ãƒ¼ãƒ«ç­‰)";
    }

    function draw() {
        const T = parseFloat(document.getElementById('thickness').value);
        const G = parseFloat(document.getElementById('rootGap').value);
        const R = parseFloat(document.getElementById('reinf').value) || 0;
        const thetaDeg = parseFloat(document.getElementById('angle').value);
        const Y0 = parseFloat(document.getElementById('probePos').value);
        const W = parseFloat(document.getElementById('beamPath').value);
        const shape = document.getElementById('jointShape').value;
        const region = document.getElementById('region').value;
        const L = parseFloat(document.getElementById('flawLength').value);
        const wLen = parseFloat(document.getElementById('weldLength').value) || 300;
        
        const theta = thetaDeg * (Math.PI / 180);
        const y_calc = W * Math.sin(theta);
        const d_calc = W * Math.cos(theta);
        const K_calc = Y0 - y_calc;
        
        const isDouble = (shape === 'k_groove' || shape === 'x_groove');
        const isBacking = !isDouble && (Y0 - T * Math.tan(theta) >= -12.5 && Y0 - T * Math.tan(theta) <= 12.5);
        const eff_T = isBacking ? T + 9 : T;
        
        let d_disp, isRef = false;
        if (W === 0) {
            statusOverlay.innerText = "READY";
            document.getElementById('depth').value = "-"; document.getElementById('k_value').value = "-";
            singleJudgeText.innerText = "å¾…æ©Ÿä¸­"; singleJudgeText.style.color = "#aaa"; judgeOverlay.style.borderColor = "#555";
            flawTypeDisplay.innerText = "-";
            flawTypeDisplay.style.color = "#fff";
        } else {
            if (d_calc <= eff_T) { d_disp = d_calc; isRef = false; }
            else { d_disp = eff_T - (d_calc - eff_T); isRef = true; }
            
            document.getElementById('depth').value = d_disp.toFixed(1);
            document.getElementById('k_value').value = K_calc.toFixed(1);
            statusOverlay.innerText = isRef ? "1.0 SKIP (åå°„)" : (isBacking && d_calc > T ? "0.5 SKIP (è£é‡‘é€é)" : "0.5 SKIP (ç›´å°„)");
            
            const est = estimateFlawType(T, G, d_disp, K_calc, shape, isBacking);
            flawTypeDisplay.innerText = est;
            if (est.includes("éæ¬ é™¥")) { flawTypeDisplay.style.color = "#00ff41"; }
            else if (est.includes("èåˆä¸è‰¯")) { flawTypeDisplay.style.color = "#ff3e3e"; }
            else { flawTypeDisplay.style.color = "#ff9900"; }

            const limits = getLimits(T);
            const evalResult = evaluateSingle(region, L, limits);
            singleJudgeText.innerText = evalResult.result;
            singleJudgeText.style.color = evalResult.isPass ? "#00ff41" : "#ff3e3e";
            judgeOverlay.style.borderColor = evalResult.isPass ? "#00ff41" : "#ff3e3e";
        }
        
        updateSumEvaluation(T, wLen);
        render(T, G, R, eff_T, theta, W, d_disp, isRef, shape, Y0, isDouble, isBacking);
    }

    function render(T, G, R, eff_T, theta, W, d, isRef, shape, Y0, isDouble, isBacking) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        let max_x_dist = Math.max(20, Math.abs(Y0));
        if (W > 0) {
            max_x_dist = Math.max(max_x_dist, Math.abs(Y0 - W * Math.sin(theta)));
            if (isRef) max_x_dist = Math.max(max_x_dist, Math.abs(Y0 - eff_T * Math.tan(theta)));
        }
        let scale = Math.min(8.0, 200 / (T + R*2 + 15));
        scale = Math.min(scale, (canvas.width / 2 - 40) / max_x_dist);
        
        const startY = (canvas.height / 2) - (T * scale / 2);
        const weldX = canvas.width / 2;
        const gap = G * scale;
        const gA = 35 * Math.PI / 180;
        const T_px = T * scale;
        const gW = T_px * Math.tan(gA);
        const gW_half = (T_px / 2) * Math.tan(gA);

        ctx.fillStyle = "#333"; ctx.strokeStyle = "#888"; ctx.lineWidth = 2;
        
        ctx.beginPath();
        if (shape === 'single_bevel' || shape === 'k_groove') {
            ctx.rect(weldX - gap/2 - 1000, startY, 1000, T_px);
        } else if (shape === 'x_groove') {
            ctx.moveTo(weldX - gap/2 - gW_half, startY); ctx.lineTo(weldX - gap/2, startY + T_px/2);
            ctx.lineTo(weldX - gap/2 - gW_half, startY + T_px); ctx.lineTo(weldX - gap/2 - 1000, startY + T_px);
            ctx.lineTo(weldX - gap/2 - 1000, startY); ctx.closePath();
        } else { 
            ctx.moveTo(weldX - gap/2 - gW, startY); ctx.lineTo(weldX - gap/2, startY + T_px);
            ctx.lineTo(weldX - gap/2 - 1000, startY + T_px); ctx.lineTo(weldX - gap/2 - 1000, startY); ctx.closePath();
        }
        ctx.fill(); ctx.stroke();

        ctx.beginPath();
        if (shape === 'k_groove' || shape === 'x_groove') {
            ctx.moveTo(weldX + gap/2 + gW_half, startY); ctx.lineTo(weldX + gap/2, startY + T_px/2);
            ctx.lineTo(weldX + gap/2 + gW_half, startY + T_px); ctx.lineTo(weldX + gap/2 + 1000, startY + T_px);
            ctx.lineTo(weldX + gap/2 + 1000, startY); ctx.closePath();
        } else {
            ctx.moveTo(weldX + gap/2 + gW, startY); ctx.lineTo(weldX + gap/2, startY + T_px);
            ctx.lineTo(weldX + gap/2 + 1000, startY + T_px); ctx.lineTo(weldX + gap/2 + 1000, startY); ctx.closePath();
        }
        ctx.fill(); ctx.stroke();

        if (R > 0) {
            ctx.fillStyle = "#444"; ctx.strokeStyle = "#888";
            let leftEdge = weldX - gap/2; let rightEdge = weldX + gap/2;
            if(shape==='single_bevel' || shape==='k_groove') { rightEdge += gW; }
            else if(shape==='x_groove') { leftEdge -= gW_half; rightEdge += gW_half; }
            else { leftEdge -= gW; rightEdge += gW; }
            
            ctx.beginPath(); ctx.moveTo(leftEdge, startY);
            ctx.quadraticCurveTo((leftEdge+rightEdge)/2, startY - R * scale * 2, rightEdge, startY);
            ctx.fill(); ctx.stroke();
            
            if (isDouble || (shape==='v_groove' && !isBacking)) {
                ctx.beginPath(); ctx.moveTo(leftEdge, startY + T_px);
                ctx.quadraticCurveTo((leftEdge+rightEdge)/2, startY + T_px + R * scale * 2, rightEdge, startY + T_px);
                ctx.fill(); ctx.stroke();
            }
        }

        if (!isDouble) {
            ctx.fillStyle = "#222"; ctx.fillRect(weldX - 12.5 * scale, startY + T_px, 25 * scale, 9 * scale);
            ctx.strokeRect(weldX - 12.5 * scale, startY + T_px, 25 * scale, 9 * scale);
        }

        const originX = (shape === 'single_bevel' || shape === 'k_groove') ? weldX - gap/2 : weldX;
        ctx.setLineDash([5, 5]); ctx.strokeStyle = "rgba(0,150,255,0.6)";
        ctx.beginPath(); ctx.moveTo(originX, 0); ctx.lineTo(originX, canvas.height); ctx.stroke(); ctx.setLineDash([]);

        const pX = originX + Y0 * scale;
        ctx.fillStyle = "#ccc"; ctx.fillRect(pX - 15, startY - 20, 30, 20);
        if (W > 0) {
            ctx.strokeStyle = "#00ff41"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(pX, startY);
            let fX, fY;
            if (!isRef) { 
                fX = pX - W * Math.sin(theta) * scale; fY = startY + W * Math.cos(theta) * scale; ctx.lineTo(fX, fY); 
            } else {
                const rX = pX - eff_T * Math.tan(theta) * scale; ctx.lineTo(rX, startY + eff_T * scale);
                const bW = eff_T / Math.cos(theta);
                fX = rX - (W - bW) * Math.sin(theta) * scale; fY = (startY + eff_T * scale) - (W - bW) * Math.cos(theta) * scale;
                ctx.lineTo(fX, fY);
            }
            ctx.stroke();
            ctx.beginPath(); ctx.arc(fX, fY, 6, 0, Math.PI*2); ctx.fillStyle = "#ff3e3e"; ctx.fill();
        }
    }
    draw();
</script>
</body>
</html>