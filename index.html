<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UT-Visualizer Pro (Manual Edition v31)</title>
    <style>
        :root { --bg-color: #1a1a1a; --panel-color: #262626; --accent-color: #00ff41; --text-color: #e0e0e0; --grid-color: rgba(0, 255, 65, 0.05); }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Courier New', Courier, monospace; margin: 0; display: flex; flex-direction: column; height: 100vh; }
        header { padding: 12px 20px; border-bottom: 2px solid var(--accent-color); background-color: #000; display: flex; justify-content: space-between; align-items: center; }
        .main-container { display: flex; flex: 1; overflow: hidden; flex-direction: row; }
        .canvas-area { flex: 2; position: relative; background-color: #111; background-image: linear-gradient(var(--grid-color) 1px, transparent 1px), linear-gradient(90deg, var(--grid-color) 1px, transparent 1px); background-size: 20px 20px; display: flex; align-items: center; justify-content: center; }
        canvas { background-color: transparent; box-shadow: 0 0 30px rgba(0,0,0,0.8); max-width: 100%; height: auto; }
        #statusOverlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: var(--accent-color); font-weight: bold; font-size: 1.2rem; text-shadow: 0 0 10px rgba(0, 255, 65, 0.5); background-color: rgba(0,0,0,0.8); padding: 5px 15px; border: 1px dashed var(--accent-color); }
        #judgeOverlay { position: absolute; top: 20px; right: 20px; font-weight: bold; font-size: 1.5rem; background-color: rgba(0,0,0,0.8); padding: 10px 20px; border: 2px solid #555; border-radius: 5px; }

        .input-panel { flex: 1; min-width: 320px; max-width: 400px; background-color: var(--panel-color); padding: 20px; border-left: 2px solid var(--accent-color); overflow-y: auto; display: flex; flex-direction: column; gap: 12px; }
        .input-group label { display: block; font-size: 0.8rem; color: var(--accent-color); margin-bottom: 4px; }
        .input-group input, .input-group select { width: 100%; background: #000; border: 1px solid #444; color: #fff; padding: 10px; font-size: 1rem; box-sizing: border-box; font-family: 'Courier New', monospace; }
        .input-group input:focus, .input-group select:focus { border-color: var(--accent-color); outline: none; }
        input[readonly] { color: #888; border-color: #222; }
        
        .flaw-estimation { border: 1px dashed #ff9900; padding: 12px; background: rgba(255,153,0,0.1); margin-top: 5px; }
        .flaw-estimation label { color: #ff9900; font-size: 0.85rem; font-weight: bold; }
        .flaw-estimation div { font-weight: bold; color: #fff; font-size: 1.1rem; margin-top: 5px; letter-spacing: 1px; }

        @media (max-width: 768px) { .main-container { flex-direction: column; } .canvas-area { flex: 1; min-height: 350px; } .input-panel { border-left: none; border-top: 2px solid var(--accent-color); height: auto; } }
    </style>
</head>
<body>

<header>
    <div style="font-weight: bold;">UT-VISUALIZER // MANUAL_v31</div>
    <div style="font-size: 0.8rem; opacity: 0.7;">è£½ä½œè€…: Y.HIGA</div>
</header>

<div class="main-container">
    <div class="canvas-area">
        <canvas id="utCanvas" width="800" height="500"></canvas>
        <div id="statusOverlay">READY</div>
        <div id="judgeOverlay" style="color:#aaa;">åˆ¤å®šå¾…ã¡</div>
    </div>

    <div class="input-panel" id="inputs">
        <div style="display: flex; gap: 10px;">
            <div class="input-group" style="flex: 1;">
                <label>æ¿åš T (mm)</label>
                <select id="thickness">
                    <option value="9" selected>9</option>
                    <option value="12">12</option>
                    <option value="16">16</option>
                    <option value="19">19</option>
                    <option value="22">22</option>
                    <option value="25">25</option>
                    <option value="50">50</option>
                </select>
            </div>
            <div class="input-group" style="flex: 1;">
                <label>ãƒ«ãƒ¼ãƒˆã‚®ãƒ£ãƒƒãƒ— G</label>
                <input type="number" id="rootGap" value="7.0" step="1.0">
            </div>
        </div>
        
        <div class="input-group">
            <label>é–‹å…ˆå½¢çŠ¶ (Joint Shape)</label>
            <select id="jointShape">
                <option value="single_bevel" selected>ãƒ¬å½¢é–‹å…ˆ (ç‰‡å´å‚ç›´)</option>
                <option value="v_groove">Vå½¢é–‹å…ˆ (ä¸¡å´æ–œã‚)</option>
            </select>
        </div>

        <div style="display: flex; gap: 10px;">
            <div class="input-group" style="flex: 1;">
                <label>å±ˆæŠ˜è§’ Î¸ (deg)</label>
                <input type="number" id="angle" value="0.0" step="0.1">
            </div>
            <div class="input-group" style="flex: 1;">
                <label>æ¢è§¦å­ Y0 (mm)</label>
                <input type="number" id="probePos" value="0.0" step="0.5">
            </div>
        </div>

        <div class="input-group">
            <label>ãƒ“ãƒ¼ãƒ è·¯ç¨‹ W (mm)</label>
            <input type="number" id="beamPath" value="0.0" step="0.1" style="font-weight:bold; color:#fff; background:#333; border: 2px solid #00ff41;">
        </div>

        <div style="display: flex; gap: 10px;">
            <div class="input-group" style="flex: 1;">
                <label>æ·±ã• d (mm)</label>
                <input type="number" id="depth" value="-" readonly>
            </div>
            <div class="input-group" style="flex: 1;">
                <label>æ¬ é™¥ä½ç½® K (mm)</label>
                <input type="number" id="k_value" value="-" readonly style="color:#00ff41; font-weight:bold;">
            </div>
        </div>

        <div class="flaw-estimation">
            <label>ğŸ¤– æ¨å®šã•ã‚Œã‚‹æ¬ é™¥å†…å®¹</label>
            <div id="flawType">-</div>
        </div>
        
        <div style="border-top: 1px solid #444; margin: 5px 0;"></div>

        <div style="font-size: 0.85rem; color: #ff9900; margin-bottom: -5px; font-weight: bold;">ã€ åˆå¦åˆ¤å®šå…¥åŠ› ã€‘</div>
        <div style="display: flex; gap: 10px;">
            <div class="input-group" style="flex: 1;">
                <label>é ˜åŸŸ (ã‚¨ã‚³ãƒ¼é«˜ã•)</label>
                <select id="region">
                    <option value="-">-</option>
                    <option value="I" selected>â…  (1)</option>
                    <option value="II">â…¡ (2)</option>
                    <option value="III">â…¢ (3)</option>
                    <option value="IV">â…£ (4)</option>
                </select>
            </div>
            <div class="input-group" style="flex: 1;">
                <label>æŒ‡ç¤ºé•·ã• L (mm)</label>
                <input type="number" id="flawLength" value="0.0" step="1.0">
            </div>
        </div>

        <div style="margin-top: auto; text-align: center; font-size: 0.7rem; color: #666; padding-top: 15px;">
            è£½ä½œè€…: Y.HIGA<br>
            MIYAMASA KOGYO DESIGN DEPT.
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('utCanvas');
    const ctx = canvas.getContext('2d');
    const statusOverlay = document.getElementById('statusOverlay');
    const judgeOverlay = document.getElementById('judgeOverlay');
    const flawTypeDisplay = document.getElementById('flawType');

    const inputs = document.querySelectorAll('#inputs input, #inputs select');
    inputs.forEach(input => {
        input.addEventListener('input', draw);
        input.addEventListener('change', draw);
        input.addEventListener('keyup', draw);
    });

    function judgeFlaw(region, L, W) {
        if (W === 0) return { text: "å¾…æ©Ÿä¸­", color: "#aaa", border: "#555" };
        if (region === "-") return { text: "åˆ¤å®šå¾…ã¡", color: "#aaa", border: "#555" };
        if (region === "I") return { text: "åˆ æ ¼", color: "#00ff41", border: "#00ff41" };
        if (region === "IV") return { text: "ä¸åˆæ ¼", color: "#ff3e3e", border: "#ff3e3e" };
        if (region === "II" || region === "III") {
            // â€»ä»®ã®ç¤¾å†…åŸºæº–
            if (L <= 30) return { text: "åˆ æ ¼", color: "#00ff41", border: "#00ff41" }; 
            else return { text: "ä¸åˆæ ¼", color: "#ff3e3e", border: "#ff3e3e" };
        }
        return { text: "ã‚¨ãƒ©ãƒ¼", color: "#ff9900", border: "#ff9900" };
    }

    function estimateFlawType(T, G, d, K, jointShape) {
        const tol_K = 2.5; 
        const tol_d = 2.0;

        if (d > T + 0.5) return "è£å½“ã¦é‡‘å†…éƒ¨ (ã ã‚Œè¾¼ã¿ç­‰)";

        if (Math.abs(d - T) <= tol_d) {
            if (jointShape === 'single_bevel' && K >= -tol_K && K <= G + tol_K) {
                return "ãƒ«ãƒ¼ãƒˆéƒ¨ (æº¶è¾¼ã¿ä¸è‰¯/ã‚¹ãƒ©ã‚°å·»è¾¼)";
            } else if (jointShape === 'v_groove' && K >= -G/2 - tol_K && K <= G/2 + tol_K) {
                return "ãƒ«ãƒ¼ãƒˆéƒ¨ (æº¶è¾¼ã¿ä¸è‰¯/ã‚¹ãƒ©ã‚°å·»è¾¼)";
            }
        }

        if (d >= 0 && d <= T) {
            const angleRad = 35 * (Math.PI / 180);
            if (jointShape === 'single_bevel') {
                const rightFaceK = G + (T - d) * Math.tan(angleRad);
                const leftFaceK = 0;
                
                if (Math.abs(K - leftFaceK) <= tol_K) return "å‚ç›´é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)";
                if (Math.abs(K - rightFaceK) <= tol_K) return "æ–œã‚é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)";
                if (K > leftFaceK + tol_K && K < rightFaceK - tol_K) return "æº¶æ¥é‡‘å±å†… (ãƒ–ãƒ­ãƒ¼ãƒ›ãƒ¼ãƒ«ç­‰)";
            } else {
                const rightFaceK = G/2 + (T - d) * Math.tan(angleRad);
                const leftFaceK = -G/2 - (T - d) * Math.tan(angleRad);
                
                if (Math.abs(K - rightFaceK) <= tol_K || Math.abs(K - leftFaceK) <= tol_K) return "é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)";
                if (K > leftFaceK + tol_K && K < rightFaceK - tol_K) return "æº¶æ¥é‡‘å±å†… (ãƒ–ãƒ­ãƒ¼ãƒ›ãƒ¼ãƒ«ç­‰)";
            }
        }

        return "æ¯æå†…éƒ¨ (ã‚­ã‚º / ãƒ©ãƒ¡ãƒ©ãƒ¼ãƒ†ã‚¢ç­‰)";
    }

    function draw() {
        const T = parseFloat(document.getElementById('thickness').value) || 25;
        const G = parseFloat(document.getElementById('rootGap').value) || 7;
        const thetaDeg = parseFloat(document.getElementById('angle').value) || 0; 
        const Y0 = parseFloat(document.getElementById('probePos').value) || 0; 
        const W = parseFloat(document.getElementById('beamPath').value) || 0;
        const jointShape = document.getElementById('jointShape').value;
        const region = document.getElementById('region').value;
        const L = parseFloat(document.getElementById('flawLength').value) || 0;
        
        const theta = thetaDeg * (Math.PI / 180);

        const y_calc = W * Math.sin(theta);
        const d_calc = W * Math.cos(theta);
        
        const K_calc = Y0 - y_calc;

        const x_at_T = Y0 - T * Math.tan(theta);
        const isHitBackingBar = (x_at_T >= -12.5 && x_at_T <= 12.5);
        const effective_T = isHitBackingBar ? T + 9 : T;
        
        let d_display = 0; let isReflected = false; let skipText = "";
        
        if (W === 0) {
            skipText = "READY";
            document.getElementById('depth').value = "-";
            document.getElementById('k_value').value = "-";
        } else {
            if (d_calc <= effective_T) {
                d_display = d_calc; isReflected = false; 
                skipText = (isHitBackingBar && d_calc > T) ? "0.5 SKIP (è£å½“ã¦é‡‘ã¸é€é)" : "0.5 SKIP (ç›´å°„)";
            } else {
                d_display = effective_T - (d_calc - effective_T); isReflected = true; skipText = "1.0 SKIP (åå°„)";
            }
            document.getElementById('depth').value = d_display.toFixed(1);
            document.getElementById('k_value').value = K_calc.toFixed(1);
        }
        statusOverlay.innerText = skipText;

        const judgment = judgeFlaw(region, L, W);
        judgeOverlay.innerText = judgment.text;
        judgeOverlay.style.color = judgment.color;
        judgeOverlay.style.borderColor = judgment.border;

        // â˜…WãŒ0ã®æ™‚ã¯æ¨å®šã—ãªã„
        const estimation = (W === 0) ? "æœªå…¥åŠ›" : estimateFlawType(T, G, d_display, K_calc, jointShape);
        flawTypeDisplay.innerText = estimation;
        
        if (estimation.includes("èåˆä¸è‰¯")) flawTypeDisplay.style.color = "#ff3e3e"; 
        else if (estimation.includes("ãƒ–ãƒ­ãƒ¼ãƒ›ãƒ¼ãƒ«")) flawTypeDisplay.style.color = "#00ff41"; 
        else if (estimation.includes("ã ã‚Œè¾¼ã¿")) flawTypeDisplay.style.color = "#ff9900"; 
        else flawTypeDisplay.style.color = "#fff";

        renderPhysicsView(T, G, effective_T, theta, W, y_calc, d_display, isReflected, jointShape, Y0);
    }

    function renderPhysicsView(T, G, effective_T, theta, W, y, d, isReflected, jointShape, Y0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const scale = Math.min(8.0, 250 / T); 
        const centerY = canvas.height / 2; const startY = centerY - (T * scale) / 2; const weldCenterX = 250; 
        ctx.save();
        
        const plateWidth = 1000; 
        const gap = G * scale;
        const backingHeight = 9 * scale; const backingWidth = 25 * scale; 
        
        ctx.fillStyle = "#333"; ctx.strokeStyle = "#888"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.rect(weldCenterX - gap/2 - plateWidth, startY, plateWidth, T * scale); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.rect(weldCenterX + gap/2, startY, plateWidth, T * scale); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "#222"; ctx.strokeStyle = "#666";
        ctx.beginPath(); ctx.rect(weldCenterX - backingWidth/2, startY + T*scale, backingWidth, backingHeight); ctx.fill(); ctx.stroke();
        const grooveAngle = 35 * (Math.PI / 180); const grooveTopWidth = (T * scale) * Math.tan(grooveAngle);
        ctx.fillStyle = "rgba(80, 80, 80, 0.8)"; ctx.beginPath(); ctx.moveTo(weldCenterX - gap/2, startY + T*scale); ctx.lineTo(weldCenterX + gap/2, startY + T*scale); 
        
        if (jointShape === 'single_bevel') { 
            ctx.lineTo(weldCenterX + gap/2 + grooveTopWidth, startY); 
            ctx.lineTo(weldCenterX - gap/2, startY); 
        } else { 
            ctx.lineTo(weldCenterX + gap/2 + grooveTopWidth, startY); 
            ctx.lineTo(weldCenterX - gap/2 - grooveTopWidth, startY); 
        }
        ctx.closePath(); ctx.fill(); ctx.stroke();
        
        const originX = (jointShape === 'single_bevel') ? (weldCenterX - gap/2) : weldCenterX;
        
        ctx.beginPath(); ctx.strokeStyle = "rgba(0, 150, 255, 0.5)"; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
        ctx.moveTo(originX, 0); ctx.lineTo(originX, canvas.height); ctx.stroke(); ctx.setLineDash([]);
        
        const probeX = originX + Y0 * scale; 
        ctx.fillStyle = "#ccc"; ctx.fillRect(probeX - 20, startY - 25, 40, 25); ctx.strokeStyle = "#fff"; ctx.strokeRect(probeX - 20, startY - 25, 40, 25);
        ctx.beginPath(); ctx.strokeStyle = "#555"; ctx.lineWidth = 2; ctx.moveTo(probeX + 10, startY - 25); ctx.bezierCurveTo(probeX + 20, startY - 50, probeX + 40, startY - 10, probeX + 60, startY - 30); ctx.stroke();
        
        ctx.fillStyle = "#ff3e3e";
        ctx.beginPath();
        ctx.moveTo(probeX, startY); 
        ctx.lineTo(probeX - 6, startY - 10);
        ctx.lineTo(probeX + 6, startY - 10);
        ctx.fill();

        // â˜… WãŒ0ã‚ˆã‚Šå¤§ãã„å ´åˆã®ã¿ã€ãƒ“ãƒ¼ãƒ ã¨ã‚­ã‚ºã‚’æç”»ã™ã‚‹
        if (W > 0) {
            ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = "#00ff41"; ctx.moveTo(probeX, startY);
            let flawX, flawY;

            if (!isReflected) {
                const x_move = W * Math.sin(theta) * scale; const y_move = W * Math.cos(theta) * scale; flawX = probeX - x_move; flawY = startY + y_move; ctx.lineTo(flawX, flawY);
            } else {
                ctx.setLineDash([5, 5]); const x_to_bottom = effective_T * Math.tan(theta) * scale; const reflectX = probeX - x_to_bottom; const reflectY = startY + effective_T * scale; ctx.lineTo(reflectX, reflectY);
                const W_to_bottom = effective_T / Math.cos(theta); const W_remain = W - W_to_bottom; const x_move_2 = W_remain * Math.sin(theta) * scale; const y_move_2 = W_remain * Math.cos(theta) * scale; flawX = reflectX - x_move_2; flawY = reflectY - y_move_2; ctx.lineTo(flawX, flawY);
            }
            
            ctx.stroke(); ctx.setLineDash([]);
            ctx.beginPath(); ctx.arc(flawX, flawY, 5, 0, Math.PI * 2); ctx.fillStyle = "#ff3e3e"; ctx.fill(); ctx.strokeStyle = "#ff3e3e"; ctx.beginPath(); ctx.arc(flawX, flawY, 10, 0, Math.PI * 2); ctx.stroke();
        }
        ctx.restore();
    }
    
    draw();
</script>
</body>
</html>