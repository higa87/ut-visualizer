<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UT-Visualizer Pro (Miyasho Edition v23)</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        :root { --bg-color: #1a1a1a; --panel-color: #262626; --accent-color: #00ff41; --text-color: #e0e0e0; --grid-color: rgba(0, 255, 65, 0.05); }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: sans-serif; margin: 0; display: flex; flex-direction: column; height: 100vh; }
        header { padding: 12px 20px; border-bottom: 2px solid var(--accent-color); background-color: #000; display: flex; justify-content: space-between; align-items: center; }
        .main-container { display: flex; flex: 1; overflow: hidden; flex-direction: row; }
        .canvas-area { flex: 2; position: relative; background-color: #111; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        canvas { max-width: 100%; height: auto; }
        #statusOverlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: var(--accent-color); font-weight: bold; background-color: rgba(0,0,0,0.8); padding: 5px 15px; border: 1px dashed var(--accent-color); }
        #ocrLoading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); color: var(--accent-color); padding: 25px; border: 2px solid var(--accent-color); z-index: 100; display: none; text-align: center; }
        .input-panel { flex: 1; min-width: 320px; max-width: 400px; background-color: var(--panel-color); padding: 20px; border-left: 2px solid var(--accent-color); overflow-y: auto; display: flex; flex-direction: column; gap: 12px; }
        .input-group label { display: block; font-size: 0.8rem; color: var(--accent-color); margin-bottom: 4px; }
        .input-group input, .input-group select { width: 100%; background: #000; border: 1px solid #444; color: #fff; padding: 10px; font-size: 1rem; box-sizing: border-box; }
        .btn-photo { width: 100%; padding: 15px; background-color: var(--accent-color); color: #000; border: none; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px; border-radius: 4px; }
        .btn-doc { background-color: #ff9900; margin-top: 5px; }
        #imgPreview { width: 100%; height: auto; border: 1px solid #444; margin-top: 5px; display: none; }
        @media (max-width: 768px) { .main-container { flex-direction: column; } .canvas-area { flex: 1; min-height: 300px; } .input-panel { border-left: none; border-top: 2px solid var(--accent-color); } }
    </style>
</head>
<body>

<header>
    <div style="font-weight: bold;">UT-VISUALIZER // å®®æ˜Œå·¥æ¥­ v23</div>
    <div style="font-size: 0.8rem; opacity: 0.7;">é–‹å…ˆå¾©æ´»ï¼†ç²¾åº¦å‘ä¸Šç‰ˆ</div>
</header>

<div class="main-container">
    <div class="canvas-area">
        <canvas id="utCanvas" width="800" height="500"></canvas>
        <div id="statusOverlay">æº–å‚™å®Œäº†</div>
        <div id="ocrLoading">
            <div id="ocrModeText" style="font-weight:bold; margin-bottom:5px;">AIãŒç”»åƒã‚’è§£æä¸­...</div>
            <div id="ocrProgress" style="font-size:1.5rem;">0%</div>
            <div id="ocrStep" style="font-size:0.7rem; color:#aaa; margin-top:10px;"></div>
        </div>
    </div>

    <div class="input-panel">
        <div class="input-group">
            <label>æ¿åš T (mm) âš ï¸ã¾ãšã“ã‚Œã‚’é¸æŠ</label>
            <select id="thickness" onchange="draw()">
                <option value="9">9 mm</option><option value="12">12 mm</option><option value="16">16 mm</option><option value="19">19 mm</option>
                <option value="22">22 mm</option><option value="25" selected>25 mm</option><option value="28">28 mm</option><option value="32">32 mm</option>
            </select>
        </div>
        
        <div class="input-group">
            <label>é–‹å…ˆå½¢çŠ¶ (Joint Shape)</label>
            <select id="jointShape" onchange="draw()">
                <option value="single_bevel">ãƒ¬å½¢é–‹å…ˆ (ç‰‡å´å‚ç›´)</option>
                <option value="v_groove">Vå½¢é–‹å…ˆ (ä¸¡å´æ–œã‚)</option>
            </select>
        </div>

        <div class="input-group">
            <label>å±ˆæŠ˜è§’ Î¸ (deg)</label>
            <input type="number" id="angle" value="69.0" step="0.1" oninput="draw()">
        </div>
        <div class="input-group">
            <label>æ¢è§¦å­ä½ç½® Y0 (mm)</label>
            <input type="number" id="probePos" value="30.0" step="0.5" oninput="draw()">
        </div>
        <div class="input-group">
            <label>ãƒ“ãƒ¼ãƒ è·¯ç¨‹ W (mm)</label>
            <input type="number" id="beamPath" value="18.1" step="0.5" oninput="draw()" style="font-weight:bold; color:#00ff41;">
        </div>
        
        <div style="border-top: 1px solid #444; margin: 10px 0;"></div>
        
        <div class="input-group">
            <input type="file" id="fileInput" accept="image/*" style="display: none;">
            <button class="btn-photo" onclick="startOCR('machine')">ğŸ¯ æ¢å‚·å™¨ã‚’ã‚¹ã‚­ãƒ£ãƒ³</button>
            <button class="btn-photo btn-doc" onclick="startOCR('doc')">ğŸ“„ æ¤œæŸ»è¡¨ã‚’ã‚¹ã‚­ãƒ£ãƒ³</button>
            <img id="imgPreview" alt="ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼">
            <div id="ocrResult" style="font-size: 0.7rem; color: #aaa; margin-top: 5px; white-space: pre-wrap;"></div>
        </div>

        <div class="input-group">
            <label>è¨ˆç®—çµæœ (d:æ·±ã• / y:æ°´å¹³è·é›¢)</label>
            <div style="display: flex; gap: 5px;">
                <input type="text" id="depth" readonly style="flex:1;">
                <input type="text" id="distance" readonly style="flex:1;">
            </div>
        </div>
        <div style="margin-top: auto; text-align: center; font-size: 0.7rem; color: #666;">
            è£½ä½œè€…: æ¯”å˜‰ ç¾©æœ (è¨­è¨ˆéƒ¨ä¸»ä»»)
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('utCanvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');
    let ocrMode = 'machine';

    function startOCR(mode) { ocrMode = mode; fileInput.click(); }

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const loading = document.getElementById('ocrLoading');
        const stepDisplay = document.getElementById('ocrStep');
        loading.style.display = 'block';
        stepDisplay.innerText = "ç”»åƒã‚’å‡¦ç†ã—ã¦ã„ã¾ã™...";

        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = async () => {
                const MAX_SIZE = 600;
                let w = img.width; let h = img.height;
                if (w > MAX_SIZE) { h *= MAX_SIZE / w; w = MAX_SIZE; }
                const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
                const tCtx = tmp.getContext('2d');
                tCtx.filter = 'grayscale(100%)'; 
                tCtx.drawImage(img, 0, 0, w, h);
                const dataUrl = tmp.toDataURL('image/jpeg', 0.8);
                document.getElementById('imgPreview').src = dataUrl;
                document.getElementById('imgPreview').style.display = 'block';

                stepDisplay.innerText = "æ–‡å­—ã‚’æŠ½å‡ºä¸­...";
                try {
                    const worker = await Tesseract.createWorker('eng', 1, { 
                        logger: m => { if (m.status === 'recognizing text') document.getElementById('ocrProgress').innerText = Math.round(m.progress * 100) + '%'; } 
                    });
                    
                    // v23ã®ã‚­ãƒ¢ï¼šAIã«ã€Œã“ã‚Œã¯1è¡Œã ã‘ã®ãƒ†ã‚­ã‚¹ãƒˆã ã€ã¨æ•™ãˆè¾¼ã‚€ (PSM: 7)
                    await worker.setParameters({
                        tessedit_char_whitelist: '0123456789. ',
                        tessedit_pageseg_mode: '7' 
                    });

                    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), 30000));
                    const recognizePromise = worker.recognize(dataUrl).then(res => { worker.terminate(); return res.data.text; });

                    const text = await Promise.race([recognizePromise, timeoutPromise]);
                    document.getElementById('ocrResult').innerText = "AIç”Ÿãƒ‡ãƒ¼ã‚¿: " + text;
                    
                    const nums = text.match(/\d+(?:\.\d+)?/g);
                    if (nums && nums.length > 0) {
                        const clean = nums.map(Number).filter(n => n > 1 && n < 500);
                        if (clean.length > 0) {
                            if (ocrMode === 'machine') { document.getElementById('beamPath').value = Math.max(...clean); }
                            else {
                                const decimals = clean.filter(n => n % 1 !== 0);
                                const integers = clean.filter(n => n % 1 === 0);
                                if (decimals.length > 0) document.getElementById('beamPath').value = Math.max(...decimals);
                                if (integers.length > 0) document.getElementById('probePos').value = Math.max(...integers);
                            }
                            draw();
                        } else { alert("æœ‰åŠ¹ãªæ•°å­—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"); }
                    } else { alert("æ•°å­—ã‚’èªè­˜ã§ãã¾ã›ã‚“ã€‚è¡¨ã®æ ç·šã‚’å…¥ã‚Œãšã«ã€æ•°å­—ã ã‘ã‚’ã‚¢ãƒƒãƒ—ã§æ’®ã£ã¦ãã ã•ã„ï¼"); }
                } catch (err) { alert("ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚"); }
                loading.style.display = 'none';
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    function draw() {
        const T = parseFloat(document.getElementById('thickness').value) || 25;
        const jointShape = document.getElementById('jointShape').value;
        const theta = (parseFloat(document.getElementById('angle').value) || 70) * Math.PI / 180;
        const Y0 = parseFloat(document.getElementById('probePos').value) || 0;
        const W = parseFloat(document.getElementById('beamPath').value) || 0;
        
        const y = W * Math.sin(theta);
        const d_raw = W * Math.cos(theta);
        const x_at_T = Y0 - T * Math.tan(theta);
        const isBacking = (x_at_T >= -12.5 && x_at_T <= 12.5);
        const eff_T = isBacking ? T + 9 : T;
        
        let d, skip;
        if (d_raw <= eff_T) { d = d_raw; skip = isBacking && d_raw > T ? "è£å½“ã¦é‡‘ é€é" : "0.5 SKIP (ç›´å°„)"; }
        else { d = eff_T - (d_raw - eff_T); skip = "1.0 SKIP (åå°„)"; }
        
        document.getElementById('depth').value = d.toFixed(1);
        document.getElementById('distance').value = y.toFixed(1);
        document.getElementById('statusOverlay').innerText = skip;
        
        ctx.clearRect(0,0,800,500);
        const s = Math.min(6, 220/T); const weldX = 250; const startY = 250 - (T*s)/2;
        
        ctx.fillStyle = "#333"; ctx.strokeStyle = "#888"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.rect(weldX + 7*s/2, startY, 1000, T*s); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.rect(weldX - 7*s/2 - 1000, startY, 1000, T*s); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "#222"; ctx.strokeStyle = "#666";
        ctx.beginPath(); ctx.rect(weldX - 12.5*s, startY + T*s, 25*s, 9*s); ctx.fill(); ctx.stroke();
        
        // é–‹å…ˆã®æç”»å‡¦ç†
        const grooveAngle = 35 * (Math.PI / 180);
        const grooveTopWidth = (T * s) * Math.tan(grooveAngle);
        ctx.fillStyle = "rgba(80, 80, 80, 0.8)";
        ctx.beginPath();
        ctx.moveTo(weldX - 7*s/2, startY + T*s);
        ctx.lineTo(weldX + 7*s/2, startY + T*s);
        if (jointShape === 'single_bevel') {
            ctx.lineTo(weldX + 7*s/2 + grooveTopWidth, startY);
            ctx.lineTo(weldX - 7*s/2, startY);
        } else {
            ctx.lineTo(weldX + 7*s/2 + grooveTopWidth, startY);
            ctx.lineTo(weldX - 7*s/2 - grooveTopWidth, startY);
        }
        ctx.closePath();
        ctx.fill(); ctx.stroke();

        const pX = weldX + Y0*s;
        ctx.fillStyle = "#ccc"; ctx.fillRect(pX-20, startY-25, 40, 25);
        ctx.fillStyle = "#ff3e3e"; ctx.beginPath(); ctx.moveTo(pX, startY); ctx.lineTo(pX-5, startY-8); ctx.lineTo(pX+5, startY-8); ctx.fill();
        ctx.strokeStyle = "#00ff41"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(pX, startY);
        let fX, fY;
        if (d_raw <= eff_T) { fX = pX - y*s; fY = startY + d_raw*s; ctx.lineTo(fX, fY); }
        else { 
            const rX = pX - eff_T * Math.tan(theta) * s; const rY = startY + eff_T*s;
            ctx.lineTo(rX, rY); fX = rX - (y - eff_T*Math.tan(theta))*s; fY = rY - (d_raw - eff_T)*s; ctx.lineTo(fX, fY);
        }
        ctx.stroke(); ctx.fillStyle = "#ff3e3e"; ctx.beginPath(); ctx.arc(fX, fY, 5, 0, 7); ctx.fill();
    }
    draw();
</script>
</body>
</html>