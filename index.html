<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UT-Visualizer Pro (Manual Edition v46)</title>
    <style>
        :root { --bg-color: #1a1a1a; --panel-color: #262626; --accent-color: #00ff41; --text-color: #e0e0e0; --grid-color: rgba(0, 255, 65, 0.05); --fail-color: #ff3e3e; --edit-color: #ff9900; }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Courier New', Courier, monospace; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow-x: hidden; }
        header { padding: 12px 20px; border-bottom: 2px solid var(--accent-color); background-color: #000; display: flex; justify-content: space-between; align-items: center; }
        .main-container { display: flex; flex: 1; overflow: hidden; flex-direction: row; width: 100%; }
        .canvas-area { flex: 2; position: relative; background-color: #111; background-image: linear-gradient(var(--grid-color) 1px, transparent 1px), linear-gradient(90deg, var(--grid-color) 1px, transparent 1px); background-size: 20px 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; overflow: hidden; }
        canvas { background-color: transparent; max-width: 100%; height: auto; }
        #statusOverlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: var(--accent-color); font-weight: bold; font-size: 1.2rem; text-shadow: 0 0 10px rgba(0, 255, 65, 0.5); background-color: rgba(0,0,0,0.8); padding: 5px 15px; border: 1px dashed var(--accent-color); }
        #judgeOverlay { position: absolute; top: 20px; right: 20px; font-weight: bold; font-size: 1.2rem; background-color: rgba(0,0,0,0.8); padding: 10px 20px; border: 2px solid #555; border-radius: 5px; text-align: right; z-index: 10; }
        .input-panel { flex: 1; min-width: 380px; max-width: 480px; background-color: var(--panel-color); padding: 15px 20px; border-left: 2px solid var(--accent-color); overflow-y: auto; display: flex; flex-direction: column; gap: 8px; box-sizing: border-box; }
        .input-group { margin-bottom: 2px; }
        .input-group label { display: block; font-size: 0.75rem; color: var(--accent-color); margin-bottom: 2px; white-space: nowrap; }
        .input-group input, .input-group select { width: 100%; background: #000; border: 1px solid #444; color: #fff; padding: 6px 8px; font-size: 0.95rem; box-sizing: border-box; font-family: 'Courier New', monospace; }
        .input-group input:focus, .input-group select:focus { border-color: var(--accent-color); outline: none; }
        input[readonly] { color: #888; border-color: #222; }
        .flaw-estimation { border: 1px dashed #ff9900; padding: 8px; background: rgba(255,153,0,0.1); margin-top: 4px; }
        .flaw-estimation label { color: #ff9900; font-size: 0.8rem; font-weight: bold; }
        .flaw-estimation div { font-weight: bold; color: #fff; font-size: 0.95rem; margin-top: 2px; }
        
        .record-section { margin-top: 5px; border-top: 2px dashed #444; padding-top: 8px; }
        .record-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .btn { background: #333; color: #fff; border: 1px solid var(--accent-color); padding: 5px 10px; cursor: pointer; font-weight: bold; transition: 0.2s; }
        .btn:hover { background: var(--accent-color); color: #000; }
        
        .action-buttons { display: flex; gap: 5px; margin-top: 5px; }
        .btn-record { background: rgba(0, 255, 65, 0.2); flex: 1; padding: 12px; font-size: 1rem; border-radius: 4px; border: 1px solid var(--accent-color); color: #fff; cursor: pointer; font-weight: bold; }
        .btn-record.mode-edit { background: rgba(255, 153, 0, 0.2); border-color: var(--edit-color); color: #fff; }
        .btn-cancel { display: none; background: #333; border: 1px solid #888; color: #ccc; padding: 12px; border-radius: 4px; cursor: pointer; font-weight: bold; }
        
        .btn-reset { border-color: var(--fail-color); color: var(--fail-color); padding: 4px 8px; font-size: 0.8rem; }
        .btn-reset:hover { background: var(--fail-color); color: #fff; }
        .record-list { max-height: 180px; overflow-y: auto; background: #111; border: 1px solid #444; padding: 5px; font-size: 0.85rem; }
        
        .record-item { position: relative; display: flex; flex-direction: column; padding: 8px; border-bottom: 1px solid #333; cursor: pointer; transition: background 0.2s; }
        .record-item:hover { background: #222; }
        .record-item.editing-item { border: 2px solid var(--edit-color); background: rgba(255,153,0,0.1); }
        .record-item:last-child { border-bottom: none; }
        .record-item-top { display: flex; justify-content: space-between; align-items: center; color: var(--accent-color); font-weight: bold; margin-bottom: 4px; }
        .record-item.editing-item .record-item-top { color: var(--edit-color); }
        .record-item-bottom { display: flex; justify-content: space-between; color: #aaa; font-size: 0.75rem; }
        .record-msg { font-size: 0.7rem; margin-top: 4px; padding: 2px 4px; border-radius: 3px; line-height: 1.3; }
        .msg-absorbed { color: #ff3e3e; background: rgba(255,62,62,0.1); border: 1px solid #ff3e3e; }
        .msg-survivor { color: var(--accent-color); background: rgba(0,255,65,0.1); border: 1px solid var(--accent-color); }
        .msg-group { color: #ff9900; background: rgba(255,153,0,0.1); border: 1px solid #ff9900; }
        
        .btn-delete { position: absolute; right: 8px; top: 12px; background: #111; border: 1px solid #666; color: #ff3e3e; border-radius: 3px; padding: 4px 10px; font-weight: bold; font-size: 0.9rem; cursor: pointer; z-index: 2; }
        .btn-delete:hover { background: #ff3e3e; color: #fff; border-color: #ff3e3e; }
        
        .sum-result { margin-top: 8px; padding: 10px; background: #000; border: 2px solid #555; text-align: center; font-size: 1.05rem; font-weight: bold; line-height: 1.4; }
        .flex-row { display: flex; gap: 6px; }
        .flex-1 { flex: 1; min-width: 0; }
        
        @media (max-width: 768px) { 
            .main-container { flex-direction: column; } 
            .canvas-area { min-height: 250px; width: 100%; } 
            .input-panel { min-width: 100%; width: 100%; max-width: none; border-left: none; border-top: 2px solid var(--accent-color); padding: 10px 15px; } 
            .input-group label { font-size: 0.7rem; }
            .input-group input, .input-group select { font-size: 1rem; padding: 8px 4px; }
            .flex-row { gap: 4px; }
            #judgeOverlay { font-size: 1rem; padding: 6px 12px; }
            #statusOverlay { font-size: 1rem; bottom: 10px; }
            .record-item { padding: 10px 6px; }
        }
    </style>
</head>
<body>

<header>
    <div style="font-weight: bold; letter-spacing: 1px;">UT-VISUALIZER // MANUAL_v46</div>
    <div style="font-size: 0.8rem; opacity: 0.7;">è£½ä½œè€… æ¯”å˜‰</div>
</header>

<div class="main-container">
    <div class="canvas-area">
        <canvas id="utCanvas" width="800" height="400"></canvas>
        <div id="statusOverlay">READY</div>
        <div id="judgeOverlay" style="color:#aaa;">
            <div style="font-size:0.75rem; color:#fff;">ã€å˜ä¸€ã‚­ã‚ºè©•ä¾¡ã€‘</div>
            <div id="singleJudgeText">å¾…æ©Ÿä¸­</div>
        </div>
    </div>

    <div class="input-panel" id="inputs">
        <div class="flex-row">
            <div class="input-group flex-1">
                <label>æ¿åš T (mm)</label>
                <select id="thickness">
                    <option value="9">9</option><option value="12">12</option>
                    <option value="16">16</option><option value="19">19</option>
                    <option value="22">22</option><option value="25">25</option>
                    <option value="28" selected>28</option><option value="32">32</option>
                    <option value="36">36</option><option value="40">40</option>
                    <option value="45">45</option><option value="50">50</option>
                </select>
            </div>
            <div class="input-group flex-1">
                <label>æº¶æ¥é•·ã• (mm)</label>
                <input type="number" id="weldLength" value="300" step="10">
            </div>
            <div class="input-group flex-1">
                <label>ä½™ç››ã‚Š (mm)</label>
                <input type="number" id="reinf" value="2.0" step="0.5">
            </div>
        </div>
        
        <div class="flex-row">
            <div class="input-group flex-1">
                <label>é–‹å…ˆå½¢çŠ¶</label>
                <select id="jointShape" onchange="onJointShapeChange()">
                    <option value="single_bevel" selected>ãƒ¬å½¢ (ç‰‡å´)</option>
                    <option value="v_groove">Vå½¢ (ä¸¡å´)</option>
                    <option value="k_groove">Kå½¢ (ä¸¡é¢)</option>
                    <option value="x_groove">Xå½¢ (ä¸¡é¢)</option>
                </select>
            </div>
            <div class="input-group flex-1">
                <label id="topAngleLabel">ä¸Šå´è§’åº¦</label>
                <select id="topAngle">
                    <option value="35" selected>35Â°</option>
                    <option value="45">45Â°</option>
                    <option value="60">60Â°</option>
                </select>
            </div>
            <div class="input-group flex-1" id="botAngleContainer" style="display:none;">
                <label>ä¸‹å´è§’åº¦</label>
                <select id="bottomAngle">
                    <option value="35">35Â°</option>
                    <option value="45">45Â°</option>
                    <option value="60">60Â°</option>
                </select>
            </div>
        </div>

        <div class="flex-row" id="dDimensions" style="display:none; background:#222; padding:4px 8px; border-radius:4px; border:1px solid #444;">
            <div class="input-group flex-1"><label>D1 (ä¸Šæ·±ã•)</label><input type="number" id="dimD1" value="13" step="1"></div>
            <div class="input-group flex-1"><label>D3 (ï¾™ï½°ï¾„é¢)</label><input type="number" id="dimD3" value="2" step="1"></div>
            <div class="input-group flex-1"><label>D2 (ä¸‹æ·±ã•)</label><input type="number" id="dimD2" value="13" step="1"></div>
        </div>
        <div id="dimWarning" style="color:#ff3e3e; font-size:0.75rem; text-align:center; display:none; font-weight:bold; margin-top:2px;">
            âš ï¸ D1 + D3 + D2 ã®åˆè¨ˆãŒæ¿åšTã¨ä¸€è‡´ã—ã¾ã›ã‚“ï¼
        </div>

        <div style="border-top: 1px solid #444; margin: 4px 0;"></div>

        <div class="flex-row">
            <div class="input-group flex-1">
                <label>ã‚®ãƒ£ãƒƒãƒ— G</label>
                <input type="number" id="rootGap" value="7.0" step="1.0">
            </div>
            <div class="input-group flex-1">
                <label>å±ˆæŠ˜è§’ Î¸</label>
                <input type="number" id="angle" value="70.0" step="0.1">
            </div>
        </div>

        <div class="flex-row">
            <div class="input-group flex-1">
                <label>æ¢è§¦å­ Y (mm)</label>
                <input type="number" id="probePos" value="0.0" step="0.5">
            </div>
            <div class="input-group flex-1">
                <label>è·¯ç¨‹ W (mm)</label>
                <input type="number" id="beamPath" value="0.0" step="0.1" style="font-weight:bold; color:#fff; background:#222; border: 2px solid var(--accent-color);">
            </div>
        </div>

        <div class="flex-row">
            <div class="input-group flex-1">
                <label>æ·±ã• d (mm)</label>
                <input type="number" id="depth" value="-" readonly>
            </div>
            <div class="input-group flex-1">
                <label>ä½ç½® K (mm)</label>
                <input type="number" id="k_value" value="-" readonly style="color:var(--accent-color); font-weight:bold;">
            </div>
        </div>

        <div class="flaw-estimation">
            <label>ğŸ¤– æ¬ é™¥æ¨å®š (AI / è©•ä¾¡å¤–è€ƒæ…®)</label>
            <div id="flawType">-</div>
        </div>
        
        <div style="border-top: 1px solid #444; margin: 4px 0;"></div>

        <div style="font-size: 0.85rem; color: #ff9900; font-weight: bold; margin-bottom: 2px;">ã€ è¨˜éŒ²ï¼†ç¾¤ãƒ»ç·å’Œè‡ªå‹•åˆ¤å®š ã€‘</div>
        <div class="flex-row">
            <div class="input-group flex-1">
                <label>Xä½ç½® (mm)</label>
                <input type="number" id="flawX" value="0.0" step="1.0">
            </div>
            <div class="input-group flex-1" style="flex: 0.6;">
                <label>é ˜åŸŸ</label>
                <select id="region">
                    <option value="I" selected>â… </option><option value="II">â…¡</option>
                    <option value="III">â…¢</option><option value="IV">â…£</option><option value="V">â…¤</option>
                </select>
            </div>
            <div class="input-group flex-1" style="flex: 0.8;">
                <label>é•·ã• L (mm)</label>
                <input type="number" id="flawLength" value="0.0" step="1.0">
            </div>
        </div>
        
        <div class="action-buttons">
            <button class="btn-record" id="btnRecord" onclick="recordCurrentFlaw()">ï¼‹ ã“ã®ä½ç½®ã®ã‚­ã‚ºã‚’è¨˜éŒ²</button>
            <button class="btn-cancel" id="btnCancel" onclick="cancelEdit()">å–æ¶ˆ</button>
        </div>

        <div class="record-section">
            <div class="record-header">
                <span style="color: var(--accent-color); font-weight: bold; font-size: 0.9rem;">ğŸ“‹ é›»å­é‡å¸³ (JASS 6æº–æ‹ )</span>
                <button class="btn btn-reset" onclick="resetRecords()">å…¨æ¶ˆå»</button>
            </div>
            <div class="record-list" id="recordList">
                <div style="color: #666; text-align: center; padding: 10px;">è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</div>
            </div>
            <div class="sum-result" id="sumResult">
                <div style="font-size: 0.8rem; color: #aaa;">ç·åˆåˆ¤å®š (ç¾¤è©•ä¾¡ï¼‹ç·å’Œ)</div>
                <span style="color: #fff;">è¨˜éŒ²ãªã—</span>
            </div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('utCanvas');
    const ctx = canvas.getContext('2d');
    const statusOverlay = document.getElementById('statusOverlay');
    const judgeOverlay = document.getElementById('judgeOverlay');
    const singleJudgeText = document.getElementById('singleJudgeText');
    const flawTypeDisplay = document.getElementById('flawType');
    
    let recordedFlaws = [];
    let flawCounter = 0;
    let editingFlawNo = null; // ç·¨é›†ä¸­ã®ã‚­ã‚ºNoã‚’ä¿æŒ
    
    const regionScores = { "I": 1, "II": 2, "III": 3, "IV": 4, "V": 5 };
    const regionNames = ["", "â… ", "â…¡", "â…¢", "â…£", "â…¤"];

    function onJointShapeChange() {
        const shape = document.getElementById('jointShape').value;
        if (shape === 'k_groove') {
            document.getElementById('topAngle').value = '60';
            document.getElementById('bottomAngle').value = '60';
            document.getElementById('dimD1').value = '13';
            document.getElementById('dimD3').value = '2';
            document.getElementById('dimD2').value = '13';
            document.getElementById('rootGap').value = '0.0';
        } else if (shape === 'single_bevel') {
            document.getElementById('topAngle').value = '35';
            document.getElementById('rootGap').value = '7.0';
        }
        toggleGrooveInputs();
    }

    function toggleGrooveInputs() {
        const shape = document.getElementById('jointShape').value;
        const botAngleContainer = document.getElementById('botAngleContainer');
        const topAngleLabel = document.getElementById('topAngleLabel');
        const dDims = document.getElementById('dDimensions');
        
        if (shape === 'k_groove' || shape === 'x_groove') {
            botAngleContainer.style.display = 'block';
            dDims.style.display = 'flex';
            topAngleLabel.innerText = "ä¸Šå´è§’åº¦";
        } else {
            botAngleContainer.style.display = 'none';
            dDims.style.display = 'none';
            topAngleLabel.innerText = "é–‹å…ˆè§’åº¦";
            document.getElementById('dimWarning').style.display = 'none';
        }
        draw();
    }

    const inputs = document.querySelectorAll('#inputs input, #inputs select');
    inputs.forEach(input => {
        ['input', 'change', 'keyup'].forEach(ev => input.addEventListener(ev, () => {
            if(input.id === 'jointShape') return;
            draw();
        }));
    });

    function getLimits(t) {
        if (t >= 6 && t <= 20) return { S: 10, M: 15, ML: 20, L: 30, LL: 40, ignore: 5 };
        if (t > 20 && t <= 48) return { S: t/2, M: t*0.75, ML: t, L: t*1.5, LL: t*2, ignore: t/4 };
        if (t > 48) return { S: 24, M: 36, ML: 48, L: 72, LL: 96, ignore: 12 };
        return { S: 0, M: 0, ML: 0, L: 0, LL: 0, ignore: 0 };
    }

    function evaluateSingleScore(rScore, length, limits) {
        if (length < limits.ignore) return true;
        if (rScore === 1) return true;
        if (rScore === 2 && length >= limits.L) return false;
        if ((rScore === 3 || rScore === 4) && length >= limits.ML) return false;
        if (rScore === 5 && length >= limits.M) return false;
        return true;
    }

    function evaluateSingle(region, length, limits) {
        if (length < limits.ignore) return { result: "è©•ä¾¡å¤– (ç„¡è¦–)", isPass: true };
        if (region === "I") return { result: "åˆ æ ¼", isPass: true };
        if (region === "II" && length >= limits.L) return { result: "ä¸åˆæ ¼ (Lä»¥ä¸Š)", isPass: false };
        if ((region === "III" || region === "IV") && length >= limits.ML) return { result: "ä¸åˆæ ¼ (MLä»¥ä¸Š)", isPass: false };
        if (region === "V" && length >= limits.M) return { result: "ä¸åˆæ ¼ (Mä»¥ä¸Š)", isPass: false };
        return { result: "åˆ æ ¼", isPass: true };
    }

    function updateSumEvaluation(t, wLen) {
        const sumBox = document.getElementById('sumResult');
        if (recordedFlaws.length === 0) {
            sumBox.innerHTML = `<div style="font-size: 0.8rem; color: #aaa;">ç·åˆåˆ¤å®š (ç¾¤è©•ä¾¡ï¼‹ç·å’Œ)</div><span style="color: #fff;">è¨˜éŒ²ãªã—</span>`;
            sumBox.style.borderColor = "#555";
            return;
        }

        const limits = getLimits(t);
        const l_0 = limits.ignore;

        recordedFlaws.forEach(f => {
            f.UI_isAbsorbed = false;
            f.UI_msg = "";
            f.UI_groupLe = null;
            f.UI_exclude = f.isExcluded || f.length < l_0;
        });

        let validFlaws = recordedFlaws.map(f => ({...f, originalNo: f.no, isAbsorbed: false}))
                                      .filter(f => !f.UI_exclude)
                                      .sort((a, b) => a.x - b.x);

        let absorbedNos = new Set();
        for (let i = 0; i < validFlaws.length; i++) {
            if (absorbedNos.has(validFlaws[i].originalNo)) continue;
            
            for (let j = i + 1; j < validFlaws.length; j++) {
                if (absorbedNos.has(validFlaws[j].originalNo)) continue;
                
                let f1 = validFlaws[i]; let f2 = validFlaws[j];
                let overlap = Math.min(f1.x + f1.length, f2.x + f2.length) - Math.max(f1.x, f2.x);
                let dd = Math.abs(parseFloat(f1.d) - parseFloat(f2.d));
                let dk = Math.abs(parseFloat(f1.k) - parseFloat(f2.k));

                if (dd <= l_0 && dk <= l_0 && overlap > 0 && overlap >= Math.min(f1.length, f2.length) / 2) {
                    let survivor, absorbed;
                    if (f2.length > f1.length) { survivor = f2; absorbed = f1; } 
                    else { survivor = f1; absorbed = f2; }

                    let worse;
                    if (regionScores[f2.region] > regionScores[f1.region]) worse = f2;
                    else if (regionScores[f1.region] > regionScores[f2.region]) worse = f1;
                    else worse = survivor;

                    survivor.region = worse.region;
                    survivor.d = worse.d; survivor.k = worse.k; survivor.y0 = worse.y0; survivor.w = worse.w;

                    absorbed.isAbsorbed = true;
                    absorbedNos.add(absorbed.originalNo);

                    let msg = "";
                    if (worse.originalNo === survivor.originalNo) {
                        msg = `â€»No.${absorbed.originalNo}ã‚’å¸å (å…¨æ•°å€¤ã‚’æœ¬ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ¡ç”¨)`;
                    } else {
                        msg = `â€»No.${absorbed.originalNo}ã‚’å¸å (X,Lã¯æœ¬ãƒ‡ãƒ¼ã‚¿ / é ˜åŸŸ,dç­‰ã¯No.${worse.originalNo}ã‚’æ¡ç”¨)`;
                    }
                    survivor.uiMsg = (survivor.uiMsg ? survivor.uiMsg + "<br>" : "") + msg;
                    absorbed.uiMsg = `[ No.${survivor.originalNo}ã¸å¸å ]`;

                    if (survivor.originalNo === f2.originalNo) break; 
                }
            }
        }

        let survivors = validFlaws.filter(f => !f.isAbsorbed);
        let clusters = [];

        for (let f of survivors) {
            if (clusters.length === 0) {
                clusters.push({ flaws: [f], start: f.x, end: f.x + f.length, maxReg: regionScores[f.region], d: parseFloat(f.d), k: parseFloat(f.k) });
                continue;
            }
            let c = clusters[clusters.length - 1];
            let gap = f.x - c.end;
            let dd = Math.abs(parseFloat(f.d) - c.d);
            let dk = Math.abs(parseFloat(f.k) - c.k);
            let maxL = Math.max(c.flaws[c.flaws.length - 1].length, f.length);

            if (gap <= maxL && dd <= l_0 && dk <= l_0) {
                c.flaws.push(f);
                c.end = Math.max(c.end, f.x + f.length);
                c.maxReg = Math.max(c.maxReg, regionScores[f.region]);
                c.d = parseFloat(f.d); c.k = parseFloat(f.k);
            } else {
                clusters.push({ flaws: [f], start: f.x, end: f.x + f.length, maxReg: regionScores[f.region], d: parseFloat(f.d), k: parseFloat(f.k) });
            }
        }

        validFlaws.forEach(vf => {
            let orig = recordedFlaws.find(r => r.no === vf.originalNo);
            if (orig) {
                orig.UI_isAbsorbed = vf.isAbsorbed;
                orig.UI_msg = vf.uiMsg || "";
            }
        });

        clusters.forEach(c => {
            let Le = c.end - c.start;
            c.flaws.forEach(cf => {
                let orig = recordedFlaws.find(r => r.no === cf.originalNo);
                if (orig && c.flaws.length > 1) {
                    orig.UI_groupLe = Le;
                }
            });
        });

        let hasSingleReject = false;
        clusters.forEach(c => {
            let Le = c.end - c.start;
            if (!evaluateSingleScore(c.maxReg, Le, limits)) hasSingleReject = true;
        });

        let windowSize = Math.min(wLen, 300);
        let maxSum = 0; let worstRegScore = 0;

        for (let i = 0; i < clusters.length; i++) {
            let winStart = clusters[i].start; let winEnd = winStart + windowSize;
            let currentSum = 0; let currentMaxReg = 0;
            
            for (let j = 0; j < clusters.length; j++) {
                let c = clusters[j];
                let overlapStart = Math.max(winStart, c.start);
                let overlapEnd = Math.min(winEnd, c.end);
                if (overlapEnd > overlapStart) {
                    currentSum += (overlapEnd - overlapStart);
                    currentMaxReg = Math.max(currentMaxReg, c.maxReg);
                }
            }
            if (currentSum > maxSum) { maxSum = currentSum; worstRegScore = currentMaxReg; }
        }

        let maxRegionStr = regionNames[worstRegScore] || "â… ";
        let sumLimit = 9999; let limitName = "-";
        if (worstRegScore === 2) { sumLimit = limits.LL; limitName = "LL"; }
        else if (worstRegScore === 3 || worstRegScore === 4) { sumLimit = limits.L; limitName = "L"; }
        else if (worstRegScore === 5) { sumLimit = limits.ML; limitName = "ML"; }

        const isSumPass = (worstRegScore === 1) || (maxSum < sumLimit);
        const isFinalPass = !hasSingleReject && isSumPass;
        
        let judgeStr = "";
        if (isFinalPass) judgeStr = "åˆ æ ¼";
        else {
            if (hasSingleReject && !isSumPass) judgeStr = "ä¸åˆæ ¼ (ç¾¤ãƒ»ç·å’ŒNG)";
            else if (hasSingleReject) judgeStr = "ä¸åˆæ ¼ (ç¾¤ã‚­ã‚ºå˜ä½“NG)";
            else judgeStr = "ä¸åˆæ ¼ (ç·å’ŒNG)";
        }

        const color = isFinalPass ? "#00ff41" : "#ff3e3e";
        sumBox.style.borderColor = color;
        sumBox.innerHTML = `
            <div style="font-size: 0.75rem; color: #aaa;">æœ€æ‚ª${windowSize}mmåŒºé–“ (é ˜åŸŸ: ${maxRegionStr} / é™ç•Œ ${limitName}=${sumLimit}mm)</div>
            <span style="color: ${color};">è©•ä¾¡é•·ã•å’Œ: ${maxSum.toFixed(1)} mm <br><b style="font-size: 1.25rem;">ã€ ${judgeStr} ã€‘</b></span>
        `;
    }

    function recordCurrentFlaw() {
        const x = parseFloat(document.getElementById('flawX').value);
        const y0 = document.getElementById('probePos').value;
        const w = document.getElementById('beamPath').value;
        const d = document.getElementById('depth').value;
        const k = document.getElementById('k_value').value;
        if (d === "-" || k === "-") { alert("Wã‚’å…¥åŠ›ã—ã¦ä½ç½®ã‚’ç¢ºå®šã—ã¦ãã ã•ã„"); return; }
        
        const region = document.getElementById('region').value;
        const length = parseFloat(document.getElementById('flawLength').value);
        const t = parseFloat(document.getElementById('thickness').value);
        const wLen = parseFloat(document.getElementById('weldLength').value);
        const estText = document.getElementById('flawType').innerText;
        const isExcluded = estText.includes("è©•ä¾¡å¤–") || estText.includes("éæ¬ é™¥");
        
        if (editingFlawNo !== null) {
            // ä¸Šæ›¸ãæ›´æ–°å‡¦ç†
            let target = recordedFlaws.find(f => f.no === editingFlawNo);
            if(target) {
                target.x = x; target.y0 = y0; target.w = w; target.d = d; target.k = k; 
                target.region = region; target.length = length; target.isExcluded = isExcluded;
            }
            cancelEdit(); // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰çµ‚äº†
        } else {
            // æ–°è¦è¿½åŠ å‡¦ç†
            flawCounter++;
            recordedFlaws.push({ no: flawCounter, x: x, y0: y0, w: w, d: d, k: k, region: region, length: length, isExcluded: isExcluded });
            
            // å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('flawX').value = "0.0";
            document.getElementById('probePos').value = "0.0";
            document.getElementById('beamPath').value = "0.0";
            document.getElementById('region').value = "I";
            document.getElementById('flawLength').value = "0.0";
        }
        
        updateSumEvaluation(t, wLen);
        renderRecordList();
        draw(); 
    }

    function deleteRecord(no) {
        if(editingFlawNo === no) cancelEdit(); // ç·¨é›†ä¸­ã®ã‚‚ã®ã‚’æ¶ˆã—ãŸã‚‰ç·¨é›†è§£é™¤
        recordedFlaws = recordedFlaws.filter(f => f.no !== no);
        const t = parseFloat(document.getElementById('thickness').value);
        const wLen = parseFloat(document.getElementById('weldLength').value);
        
        updateSumEvaluation(t, wLen);
        renderRecordList();
        draw();
    }

    function resetRecords() {
        if(confirm("é‡å¸³ãƒ‡ãƒ¼ã‚¿ã‚’å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) {
            recordedFlaws = []; flawCounter = 0;
            cancelEdit();
            const t = parseFloat(document.getElementById('thickness').value);
            const wLen = parseFloat(document.getElementById('weldLength').value);
            
            updateSumEvaluation(t, wLen);
            renderRecordList();
            draw();
        }
    }

    // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã¸ã®åˆ‡ã‚Šæ›¿ãˆ
    function loadRecord(no) {
        const f = recordedFlaws.find(item => item.no === no);
        if (!f) return;
        
        editingFlawNo = no;
        document.getElementById('flawX').value = f.x;
        document.getElementById('probePos').value = f.y0;
        document.getElementById('beamPath').value = f.w;
        document.getElementById('region').value = f.region;
        document.getElementById('flawLength').value = f.length;
        
        // ãƒœã‚¿ãƒ³UIã®å¤‰æ›´
        const btnRecord = document.getElementById('btnRecord');
        btnRecord.innerText = `ğŸ“ No.${no} ã‚’ä¸Šæ›¸ãæ›´æ–°`;
        btnRecord.classList.add('mode-edit');
        document.getElementById('btnCancel').style.display = 'block';
        
        renderRecordList(); // ãƒã‚¤ãƒ©ã‚¤ãƒˆåæ˜ 
        draw();
    }
    
    // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    function cancelEdit() {
        editingFlawNo = null;
        
        document.getElementById('flawX').value = "0.0";
        document.getElementById('probePos').value = "0.0";
        document.getElementById('beamPath').value = "0.0";
        document.getElementById('region').value = "I";
        document.getElementById('flawLength').value = "0.0";
        
        const btnRecord = document.getElementById('btnRecord');
        btnRecord.innerText = "ï¼‹ ã“ã®ä½ç½®ã®ã‚­ã‚ºã‚’è¨˜éŒ²";
        btnRecord.classList.remove('mode-edit');
        document.getElementById('btnCancel').style.display = 'none';
        
        renderRecordList(); // ãƒã‚¤ãƒ©ã‚¤ãƒˆè§£é™¤
        draw();
    }

    function renderRecordList() {
        const listDiv = document.getElementById('recordList');
        if (recordedFlaws.length === 0) { listDiv.innerHTML = '<div style="color: #666; text-align: center; padding: 10px;">è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</div>'; return; }
        let html = "";
        let sorted = [...recordedFlaws].sort((a,b) => a.x - b.x);
        sorted.forEach((f) => {
            let L_str = `L: ${f.length}`;
            let itemStyle = "";
            let msgHtml = "";
            let editClass = (f.no === editingFlawNo) ? "editing-item" : "";

            if (f.UI_exclude) {
                msgHtml = `<div class="record-msg" style="color:#888;">(è©•ä¾¡å¤– ã¾ãŸã¯ ã‚µã‚¤ã‚ºæœªæº€ã®ãŸã‚ç„¡è¦–)</div>`;
            } else if (f.UI_isAbsorbed) {
                itemStyle = "text-decoration: line-through; opacity: 0.5;";
                msgHtml = `<div class="record-msg msg-absorbed">${f.UI_msg}</div>`;
            } else {
                if (f.UI_msg) {
                    msgHtml += `<div class="record-msg msg-survivor">${f.UI_msg}</div>`;
                }
                if (f.UI_groupLe) {
                    L_str = `(L: ${f.length})`; // ç¾¤ã‚­ã‚ºã¯ã‚«ãƒƒã‚³ã§æ‹¬ã‚‹
                    msgHtml += `<div class="record-msg msg-group">â€»ç¾¤ã‚­ã‚º (Le = ${f.UI_groupLe.toFixed(1)} ã¨ã—ã¦è©•ä¾¡)</div>`;
                }
            }
            
            html += `<div class="record-item ${editClass}" onclick="loadRecord(${f.no})" title="ã‚¿ãƒƒãƒ—ã—ã¦æ•°å€¤ã‚’ä¿®æ­£ã—ã¾ã™">
                <div style="${itemStyle} padding-right:45px;">
                    <div class="record-item-top">
                        <span>No.${f.no}</span>
                        <span>é ˜åŸŸ${regionNames[regionScores[f.region]]} ${L_str}</span>
                    </div>
                    <div class="record-item-bottom">
                        <span>X: ${f.x}</span><span>Y: ${f.y0}</span><span>W: ${f.w}</span><span>d: ${f.d}</span><span>K: ${f.k}</span>
                    </div>
                    ${msgHtml}
                </div>
                <button class="btn-delete" onclick="event.stopPropagation(); deleteRecord(${f.no})">Ã—</button>
            </div>`;
        });
        listDiv.innerHTML = html;
        listDiv.scrollTop = listDiv.scrollHeight;
    }

    function getGrooveProfile(T, G, shape, topA_deg, botA_deg, D1, D3) {
        const tA = topA_deg * Math.PI / 180;
        const bA = botA_deg * Math.PI / 180;
        const isDouble = (shape === 'k_groove' || shape === 'x_groove');
        
        let eff_D1 = isDouble ? D1 : T;
        let eff_D3 = isDouble ? D3 : 0;

        return function(d) {
            let xr;
            if (!isDouble) {
                xr = G/2 + (T - d) * Math.tan(tA);
            } else {
                if (d < eff_D1) xr = G/2 + (eff_D1 - d) * Math.tan(tA);
                else if (d <= eff_D1 + eff_D3) xr = G/2;
                else xr = G/2 + (d - (eff_D1 + eff_D3)) * Math.tan(bA);
            }
            let xl = (shape === 'single_bevel' || shape === 'k_groove') ? -G/2 : -xr;
            return { left: xl, right: xr };
        };
    }

    function draw() {
        const T = parseFloat(document.getElementById('thickness').value);
        const G = parseFloat(document.getElementById('rootGap').value);
        const R = parseFloat(document.getElementById('reinf').value) || 0;
        const thetaDeg = parseFloat(document.getElementById('angle').value);
        const Y0 = parseFloat(document.getElementById('probePos').value);
        const W = parseFloat(document.getElementById('beamPath').value);
        const shape = document.getElementById('jointShape').value;
        const region = document.getElementById('region').value;
        const L = parseFloat(document.getElementById('flawLength').value);
        const wLen = parseFloat(document.getElementById('weldLength').value) || 300;
        
        const topA = parseFloat(document.getElementById('topAngle').value);
        const botA = parseFloat(document.getElementById('bottomAngle').value);
        const D1 = parseFloat(document.getElementById('dimD1').value) || 0;
        const D3 = parseFloat(document.getElementById('dimD3').value) || 0;
        const D2 = parseFloat(document.getElementById('dimD2').value) || 0;

        const isDouble = (shape === 'k_groove' || shape === 'x_groove');
        const warnEl = document.getElementById('dimWarning');
        if (isDouble && Math.abs((D1 + D2 + D3) - T) > 0.1) {
            warnEl.style.display = 'block';
        } else {
            warnEl.style.display = 'none';
        }

        const profile = getGrooveProfile(T, G, shape, topA, botA, D1, D3);

        const theta = thetaDeg * (Math.PI / 180);
        const y_calc = W * Math.sin(theta);
        const d_calc = W * Math.cos(theta);
        const K_calc = Y0 - y_calc;
        
        const isBacking = !isDouble && (Y0 - T * Math.tan(theta) >= -12.5 && Y0 - T * Math.tan(theta) <= 12.5);
        const eff_T = isBacking ? T + 9 : T;
        
        let d_disp, isRef = false;
        if (W === 0) {
            statusOverlay.innerText = "READY";
            document.getElementById('depth').value = "-"; document.getElementById('k_value').value = "-";
            singleJudgeText.innerText = "å¾…æ©Ÿä¸­"; singleJudgeText.style.color = "#aaa"; judgeOverlay.style.borderColor = "#555";
            flawTypeDisplay.innerText = "-";
            flawTypeDisplay.style.color = "#fff";
        } else {
            if (d_calc <= eff_T) { d_disp = d_calc; isRef = false; }
            else { d_disp = eff_T - (d_calc - eff_T); isRef = true; }
            
            document.getElementById('depth').value = d_disp.toFixed(1);
            document.getElementById('k_value').value = K_calc.toFixed(1);
            statusOverlay.innerText = isRef ? "1.0 SKIP (åå°„)" : (isBacking && d_calc > T ? "0.5 SKIP (è£é‡‘é€é)" : "0.5 SKIP (ç›´å°„)");
            
            let est = "æº¶æ¥é‡‘å±å†… (ãƒ–ãƒ­ãƒ¼ãƒ›ãƒ¼ãƒ«ç­‰)";
            if (d_disp < 0) est = "è¡¨é¢ä½™ç››ã‚Šã‹ã‚‰ã®åå°„ (éæ¬ é™¥)";
            else if (d_disp > T && !isBacking) est = "è£æ³¢ãƒ»è£é¢ä½™ç››ã‚Šã‹ã‚‰ã®åå°„ (éæ¬ é™¥)";
            else if (d_disp > T + 0.5 && isBacking) est = "è£å½“ã¦é‡‘å†…éƒ¨ (ã ã‚Œè¾¼ã¿ç­‰ / è©•ä¾¡å¤–)";
            else {
                const bounds = profile(d_disp);
                const tol = 2.0;
                
                if (K_calc < bounds.left - 3.0 || K_calc > bounds.right + 3.0) {
                    est = "æ¯æã®ã‚­ã‚º (é–‹å…ˆã‹ã‚‰3mmä»¥ä¸Š / è©•ä¾¡å¤–)";
                } else if (!isDouble && Math.abs(d_disp - T) < tol && Math.abs(K_calc) < G/2 + tol) {
                    est = "ãƒ«ãƒ¼ãƒˆéƒ¨ (æº¶è¾¼ã¿ä¸è‰¯)";
                } else if (isDouble && d_disp >= D1 - tol && d_disp <= D1 + D3 + tol && K_calc > bounds.left - tol && K_calc < bounds.right + tol) {
                    est = "ãƒ«ãƒ¼ãƒˆé¢éƒ¨ (æº¶è¾¼ã¿ä¸è‰¯)";
                } else if (Math.abs(K_calc - bounds.left) < tol) {
                    est = "å·¦å´é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)";
                } else if (Math.abs(K_calc - bounds.right) < tol) {
                    est = "å³å´é–‹å…ˆé¢ã®èåˆä¸è‰¯ (LF)";
                }
            }

            flawTypeDisplay.innerText = est;
            if (est.includes("éæ¬ é™¥") || est.includes("è©•ä¾¡å¤–")) { flawTypeDisplay.style.color = "#00ff41"; }
            else if (est.includes("ä¸è‰¯")) { flawTypeDisplay.style.color = "#ff3e3e"; }
            else { flawTypeDisplay.style.color = "#ff9900"; }

            let evalResult = evaluateSingle(region, L, getLimits(T));
            if (est.includes("è©•ä¾¡å¤–") || est.includes("éæ¬ é™¥")) {
                let overrideReason = "ä½™ç››ã‚Šç­‰";
                if (est.includes("æ¯æ")) overrideReason = "æ¯æ";
                if (est.includes("è£å½“ã¦é‡‘")) overrideReason = "è£å½“ã¦é‡‘";
                evalResult = { result: `è©•ä¾¡å¤– (${overrideReason})`, isPass: true };
            }

            singleJudgeText.innerText = evalResult.result;
            singleJudgeText.style.color = evalResult.isPass ? "#00ff41" : "#ff3e3e";
            judgeOverlay.style.borderColor = evalResult.isPass ? "#00ff41" : "#ff3e3e";
        }
        
        updateSumEvaluation(T, wLen);
        renderCanvas(T, R, eff_T, theta, W, d_disp, isRef, shape, Y0, isDouble, isBacking, profile, D1, D3);
    }

    function renderCanvas(T, R, eff_T, theta, W, d, isRef, shape, Y0, isDouble, isBacking, profile, D1, D3) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        let max_x_dist = Math.max(20, Math.abs(Y0));
        if (W > 0) {
            max_x_dist = Math.max(max_x_dist, Math.abs(Y0 - W * Math.sin(theta)));
            if (isRef) max_x_dist = Math.max(max_x_dist, Math.abs(Y0 - eff_T * Math.tan(theta)));
        }
        let scale = Math.min(8.0, 200 / (T + R*2 + 15));
        scale = Math.min(scale, (canvas.width / 2 - 40) / max_x_dist);
        
        const startY = (canvas.height / 2) - (T * scale / 2);
        const weldX = canvas.width / 2;

        ctx.fillStyle = "#333"; ctx.strokeStyle = "#888"; ctx.lineWidth = 2;
        
        function drawPlate(side) {
            ctx.beginPath();
            const dirX = side === 'left' ? -1000 : 1000;
            ctx.moveTo(weldX + profile(0)[side] * scale, startY);
            if (isDouble) {
                ctx.lineTo(weldX + profile(D1)[side] * scale, startY + D1 * scale);
                ctx.lineTo(weldX + profile(D1+D3)[side] * scale, startY + (D1+D3) * scale);
            } else if (shape === 'v_groove' && side === 'left') {
                ctx.lineTo(weldX + profile(T)[side] * scale, startY + T * scale);
            }
            ctx.lineTo(weldX + profile(T)[side] * scale, startY + T * scale);
            ctx.lineTo(weldX + dirX, startY + T * scale);
            ctx.lineTo(weldX + dirX, startY);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
        }

        drawPlate('left');
        drawPlate('right');

        if (R > 0) {
            ctx.fillStyle = "#444"; ctx.strokeStyle = "#888";
            let leftEdge = weldX + profile(0).left * scale; 
            let rightEdge = weldX + profile(0).right * scale;
            
            ctx.beginPath(); ctx.moveTo(leftEdge, startY);
            ctx.quadraticCurveTo((leftEdge+rightEdge)/2, startY - R * scale * 2, rightEdge, startY);
            ctx.fill(); ctx.stroke();
            
            if (isDouble || (shape==='v_groove' && !isBacking)) {
                let botLeftEdge = weldX + profile(T).left * scale;
                let botRightEdge = weldX + profile(T).right * scale;
                ctx.beginPath(); ctx.moveTo(botLeftEdge, startY + T * scale);
                ctx.quadraticCurveTo((botLeftEdge+botRightEdge)/2, startY + T * scale + R * scale * 2, botRightEdge, startY + T * scale);
                ctx.fill(); ctx.stroke();
            }
        }

        if (!isDouble) {
            ctx.fillStyle = "#222"; ctx.fillRect(weldX - 12.5 * scale, startY + T * scale, 25 * scale, 9 * scale);
            ctx.strokeRect(weldX - 12.5 * scale, startY + T * scale, 25 * scale, 9 * scale);
        }

        const originX = (shape === 'single_bevel' || shape === 'k_groove') ? weldX + profile(0).left * scale : weldX;
        ctx.setLineDash([5, 5]); ctx.strokeStyle = "rgba(0,150,255,0.6)";
        ctx.beginPath(); ctx.moveTo(originX, 0); ctx.lineTo(originX, canvas.height); ctx.stroke(); ctx.setLineDash([]);

        const pX = originX + Y0 * scale;
        ctx.fillStyle = "#ccc"; ctx.fillRect(pX - 15, startY - 20, 30, 20);
        if (W > 0) {
            ctx.strokeStyle = "#00ff41"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(pX, startY);
            let fX, fY;
            if (!isRef) { 
                fX = pX - W * Math.sin(theta) * scale; fY = startY + W * Math.cos(theta) * scale; ctx.lineTo(fX, fY); 
            } else {
                const rX = pX - eff_T * Math.tan(theta) * scale; ctx.lineTo(rX, startY + eff_T * scale);
                const bW = eff_T / Math.cos(theta);
                fX = rX - (W - bW) * Math.sin(theta) * scale; fY = (startY + eff_T * scale) - (W - bW) * Math.cos(theta) * scale;
                ctx.lineTo(fX, fY);
            }
            ctx.stroke();
            ctx.beginPath(); ctx.arc(fX, fY, 6, 0, Math.PI*2); ctx.fillStyle = "#ff3e3e"; ctx.fill();
        }
    }
    
    draw();
</script>
</body>
</html>