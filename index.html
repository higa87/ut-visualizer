<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UT-Visualizer Pro (Miyasho Edition v20)</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        :root { --bg-color: #1a1a1a; --panel-color: #262626; --accent-color: #00ff41; --text-color: #e0e0e0; --grid-color: rgba(0, 255, 65, 0.05); }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Courier New', Courier, monospace; margin: 0; display: flex; flex-direction: column; height: 100vh; }
        header { padding: 12px 20px; border-bottom: 2px solid var(--accent-color); background-color: #000; display: flex; justify-content: space-between; align-items: center; }
        .main-container { display: flex; flex: 1; overflow: hidden; flex-direction: row; }
        .canvas-area { flex: 2; position: relative; background-color: #111; background-image: linear-gradient(var(--grid-color) 1px, transparent 1px), linear-gradient(90deg, var(--grid-color) 1px, transparent 1px); background-size: 20px 20px; display: flex; align-items: center; justify-content: center; }
        canvas { background-color: transparent; box-shadow: 0 0 30px rgba(0,0,0,0.8); max-width: 100%; height: auto; }
        #statusOverlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: var(--accent-color); font-weight: bold; font-size: 1.2rem; text-shadow: 0 0 10px rgba(0, 255, 65, 0.5); background-color: rgba(0,0,0,0.8); padding: 5px 15px; border: 1px dashed var(--accent-color); }
        #ocrLoading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); color: var(--accent-color); padding: 25px; border: 2px solid var(--accent-color); z-index: 100; display: none; text-align: center; box-shadow: 0 0 20px rgba(0,255,65,0.3); }
        .input-panel { flex: 1; min-width: 320px; max-width: 400px; background-color: var(--panel-color); padding: 20px; border-left: 2px solid var(--accent-color); overflow-y: auto; display: flex; flex-direction: column; gap: 12px; }
        .input-group label { display: block; font-size: 0.8rem; color: var(--accent-color); margin-bottom: 4px; }
        .input-group input, .input-group select { width: 100%; background: #000; border: 1px solid #444; color: #fff; padding: 10px; font-size: 1rem; box-sizing: border-box; font-family: 'Courier New', monospace; }
        .input-group input:focus, .input-group select:focus { border-color: var(--accent-color); outline: none; }
        input[readonly] { color: #888; border-color: #222; }
        .btn-photo { width: 100%; padding: 12px 5px; background-color: var(--accent-color); color: #000; border: none; font-weight: bold; cursor: pointer; font-size: 0.9rem; display: flex; align-items: center; justify-content: center; gap: 5px; transition: 0.2s; border-radius: 4px; }
        .btn-photo:hover:not(:disabled) { filter: brightness(1.2); }
        .btn-photo:disabled { background-color: #555; cursor: not-allowed; color: #888; }
        .btn-doc { background-color: #ff9900; } 
        #imgPreview { width: 100%; height: auto; border: 1px solid #444; margin-top: 5px; display: none; filter: grayscale(1) contrast(1.5); }
        .instruction { font-size: 0.75rem; color: #ff9900; background: rgba(255,153,0,0.1); padding: 8px; border-left: 3px solid #ff9900; margin-bottom: 5px; }
        @media (max-width: 768px) { .main-container { flex-direction: column; } .canvas-area { flex: 1; min-height: 350px; } .input-panel { border-left: none; border-top: 2px solid var(--accent-color); height: auto; } }
    </style>
</head>
<body>

<header>
    <div style="font-weight: bold;">UT-VISUALIZER // MIYASHO_SYSTEM_v20</div>
    <div style="font-size: 0.8rem; opacity: 0.7;">NO-FREEZE OCR ENGINE</div>
</header>

<div class="main-container">
    <div class="canvas-area">
        <canvas id="utCanvas" width="800" height="500"></canvas>
        <div id="statusOverlay">READY</div>
        <div id="ocrLoading">
            <div id="ocrModeText" style="font-weight:bold; letter-spacing:2px; margin-bottom:5px;">SCANNING TARGET...</div>
            <div id="ocrProgress" style="font-size:1.5rem;">0%</div>
        </div>
    </div>

    <div class="input-panel">
        <div class="input-group">
            <label>æ¿åš T (mm) [â–½é¸æŠ] âš ï¸é‡è¦</label>
            <select id="thickness" onchange="draw()" style="border-color: #ff9900;">
                <option value="9">9 mm</option>
                <option value="12">12 mm</option>
                <option value="16">16 mm</option>
                <option value="19">19 mm</option>
                <option value="22">22 mm</option>
                <option value="25" selected>25 mm</option>
                <option value="28">28 mm</option>
                <option value="32">32 mm</option>
                <option value="36">36 mm</option>
                <option value="40">40 mm</option>
                <option value="45">45 mm</option>
                <option value="50">50 mm</option>
            </select>
        </div>
        <div class="input-group">
            <label>é–‹å…ˆå½¢çŠ¶ (Joint Shape)</label>
            <select id="jointShape" onchange="draw()">
                <option value="single_bevel">ãƒ¬å½¢é–‹å…ˆ (ç‰‡å´å‚ç›´)</option>
                <option value="v_groove">Vå½¢é–‹å…ˆ (ä¸¡å´æ–œã‚)</option>
            </select>
        </div>
        <div class="input-group">
            <label>å±ˆæŠ˜è§’ Î¸ (deg)</label>
            <input type="number" id="angle" value="69.0" step="0.1" oninput="draw()">
        </div>
        <div class="input-group" style="border: 1px solid #00ff41; padding: 10px; background: rgba(0,255,65,0.05);">
            <label>æ¢è§¦å­ä½ç½® Y0 (mm) [å…¥å°„ç‚¹]</label>
            <input type="number" id="probePos" value="30.0" step="0.5" oninput="draw()">
        </div>
        <div class="input-group">
            <label>ãƒ“ãƒ¼ãƒ è·¯ç¨‹ W (mm)</label>
            <input type="number" id="beamPath" value="18.1" step="0.5" oninput="draw()" style="font-weight:bold; color:#fff; background:#333;">
        </div>
        
        <div style="border-top: 1px solid #444; margin: 5px 0;"></div>
        
        <div class="input-group">
            <div class="instruction" id="instructionText">
                å¾…æ©Ÿä¸­...
            </div>
            <div style="display: flex; gap: 10px;">
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                <button class="btn-photo" id="btnMachine" onclick="startOCR('machine')" style="flex:1;">
                    <span>ğŸ¯</span> æ¢å‚·å™¨(W)
                </button>
                <button class="btn-photo btn-doc" id="btnDoc" onclick="startOCR('doc')" style="flex:1;">
                    <span>ğŸ“„</span> æ¤œæŸ»è¡¨(Y/W)
                </button>
            </div>
            <img id="imgPreview" alt="Preview">
            <div id="ocrResult" style="font-size: 0.75rem; color: #aaa; margin-top: 5px; white-space: pre-wrap; line-height: 1.4; max-height: 100px; overflow-y: auto;"></div>
        </div>

        <div class="input-group">
            <label>æ·±ã• d (mm)</label>
            <input type="number" id="depth" value="-" readonly>
        </div>
        <div class="input-group">
            <label>æ°´å¹³è·é›¢ y (mm)</label>
            <input type="number" id="distance" value="-" readonly>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('utCanvas');
    const ctx = canvas.getContext('2d');
    const statusOverlay = document.getElementById('statusOverlay');
    const fileInput = document.getElementById('fileInput');
    const imgPreview = document.getElementById('imgPreview');
    const ocrLoading = document.getElementById('ocrLoading');
    const ocrProgress = document.getElementById('ocrProgress');
    const ocrModeText = document.getElementById('ocrModeText');
    const ocrResult = document.getElementById('ocrResult');
    const btnMachine = document.getElementById('btnMachine');
    const btnDoc = document.getElementById('btnDoc');
    const instructionText = document.getElementById('instructionText');

    let currentOcrMode = 'machine';

    function startOCR(mode) {
        currentOcrMode = mode;
        if (mode === 'machine') {
            instructionText.innerHTML = 'âš ï¸ <b>æ¢å‚·å™¨ãƒ¢ãƒ¼ãƒ‰:</b> Wã®æ•°å€¤éƒ¨åˆ†ã‚’ãƒ‰ã‚¢ãƒƒãƒ—ã§ã€‚';
        } else {
            instructionText.innerHTML = 'âš ï¸ <b>æ¤œæŸ»è¡¨ãƒ¢ãƒ¼ãƒ‰:</b> Y ã¨ W ãŒå…¥ã‚‹ã‚ˆã†ã«æ¨ªé•·ã«æ’®å½±ã€‚åˆ¶é™ãªã—ã§çˆ†é€Ÿã§èª­ã¿ã¾ã™ã€‚';
        }
        fileInput.click();
    }

    function resetOCRUI() {
        ocrLoading.style.display = 'none';
        btnMachine.disabled = false;
        btnDoc.disabled = false;
        btnMachine.innerHTML = '<span>ğŸ¯</span> æ¢å‚·å™¨(W)';
        btnDoc.innerHTML = '<span>ğŸ“„</span> æ¤œæŸ»è¡¨(Y/W)';
        fileInput.value = ''; 
    }

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        ocrLoading.style.display = 'block';
        ocrProgress.innerText = 'LOADING...';
        ocrResult.innerText = "";
        btnMachine.disabled = true;
        btnDoc.disabled = true;
        
        ocrModeText.innerText = currentOcrMode === 'machine' ? "SCANNING MACHINE..." : "READING TABLE...";

        const reader = new FileReader();
        reader.onerror = () => { alert("èª­è¾¼å¤±æ•—"); resetOCRUI(); };

        reader.onload = (event) => {
            const img = new Image();
            img.onload = async () => {
                try {
                    const MAX_SIZE = 600;
                    let width = img.width; let height = img.height;
                    if (width > height) { if (width > MAX_SIZE) { height *= MAX_SIZE / width; width = MAX_SIZE; } }
                    else { if (height > MAX_SIZE) { width *= MAX_SIZE / height; height = MAX_SIZE; } }

                    const tmpCanvas = document.createElement('canvas');
                    tmpCanvas.width = width; tmpCanvas.height = height;
                    const tCtx = tmpCanvas.getContext('2d');
                    tCtx.drawImage(img, 0, 0, width, height);
                    const compressedDataUrl = tmpCanvas.toDataURL('image/jpeg', 0.9);
                    
                    imgPreview.src = compressedDataUrl;
                    imgPreview.style.display = 'block';

                    ocrProgress.innerText = 'SCANNING...';
                    
                    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’15ç§’ã«çŸ­ç¸®ï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—ã—ãªã„ã®ã§æ—©ãçµ‚ã‚ã‚‹ã¯ãšï¼‰
                    const timeoutPromise = new Promise((_, reject) => { setTimeout(() => reject(new Error("TIME_OUT")), 15000); });

                    const performOCR = async () => {
                        const worker = await Tesseract.createWorker({
                            logger: m => { if (m.status === 'recognizing text') ocrProgress.innerText = Math.round(m.progress * 100) + '%'; }
                        });
                        await worker.loadLanguage('eng');
                        await worker.initialize('eng');
                        
                        // â˜…v20ã®ã‚­ãƒ¢ï¼šç„¡é™ãƒ«ãƒ¼ãƒ—å›é¿
                        if (currentOcrMode === 'machine') {
                            // æ¢å‚·å™¨ãƒ¢ãƒ¼ãƒ‰ã¯èƒŒæ™¯ãŒé»’ã„ã®ã§åˆ¶é™ä»˜ãã§ã‚‚å‹•ãã‚„ã™ã„
                            await worker.setParameters({ tessedit_char_whitelist: '0123456789.' });
                        } else {
                            // æ¤œæŸ»è¡¨ãƒ¢ãƒ¼ãƒ‰ã¯ã€åˆ¶é™ã‚’å®Œå…¨æ’¤å»ƒã€‘ï¼ã‚¬ãƒ©ã‚¯ã‚¿ã”ã¨é«˜é€Ÿã§èª­ã¾ã›ã‚‹ã€‚
                            await worker.setParameters({ tessedit_pageseg_mode: '6' });
                        }

                        const res = await worker.recognize(compressedDataUrl);
                        await worker.terminate();
                        return res.data.text;
                    };

                    const text = await Promise.race([performOCR(), timeoutPromise]);
                    
                    // JSã®æ­£è¦è¡¨ç¾ã§ã€ã‚¬ãƒ©ã‚¯ã‚¿ãƒ†ã‚­ã‚¹ãƒˆã®ä¸­ã‹ã‚‰æ•°å­—ã ã‘ã‚’ã™ãã„å–ã‚‹
                    const numsMatch = text.match(/\d+(?:\.\d+)?/g);

                    if (numsMatch && numsMatch.length > 0) {
                        const cleanNums = numsMatch.map(Number).filter(n => n !== 1 && n > 0 && n < 500);

                        if (cleanNums.length > 0) {
                            if (currentOcrMode === 'machine') {
                                const bestW = Math.max(...cleanNums);
                                document.getElementById('beamPath').value = bestW;
                                draw();
                                ocrResult.innerHTML = `<span style="color:#00ff41;">æˆåŠŸ: W = ${bestW}</span>`;
                            } else {
                                const decimals = cleanNums.filter(n => n % 1 !== 0);
                                const integers = cleanNums.filter(n => n % 1 === 0);
                                
                                let extW = decimals.length > 0 ? Math.max(...decimals) : null;
                                let extY = integers.length > 0 ? Math.max(...integers) : null;

                                if (extW && extY) {
                                    document.getElementById('probePos').value = extY;
                                    document.getElementById('beamPath').value = extW;
                                    draw();
                                    ocrResult.innerHTML = `<span style="color:#ff9900;">è¡¨èª­å–æˆåŠŸï¼</span><br>Y(æ•´æ•°æœ€å¤§): ${extY} / W(å°æ•°æœ€å¤§): ${extW}<br><span style="color:#ff3e3e;">â€»æ¿åš(T)ã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„ï¼</span>`;
                                } else {
                                    ocrResult.innerText = "Yã¨Wã®çµ„ã¿åˆã‚ã›ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚\næŠ½å‡º: " + cleanNums.join(', ');
                                }
                            }
                        } else { ocrResult.innerText = "æœ‰åŠ¹ãªæ•°å­—ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"; }
                    } else { ocrResult.innerText = "æ•°å­—ã‚’èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"; }

                } catch (error) {
                    if (error.message === "TIME_OUT") { alert("ã‚¹ã‚­ãƒ£ãƒ³ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚"); } 
                    else { console.error("OCR Error:", error); alert("OCRã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"); }
                } finally {
                    resetOCRUI();
                }
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    // --- ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³æ­è¼‰ã®æç”»ãƒ­ã‚¸ãƒƒã‚¯ ---
    function draw() {
        const T = parseFloat(document.getElementById('thickness').value) || 25;
        const thetaDeg = parseFloat(document.getElementById('angle').value) || 70;
        const Y0 = parseFloat(document.getElementById('probePos').value) || 0; 
        const W = parseFloat(document.getElementById('beamPath').value) || 0;
        const jointShape = document.getElementById('jointShape').value;
        const theta = thetaDeg * (Math.PI / 180);

        const y_calc = W * Math.sin(theta);
        const d_calc = W * Math.cos(theta);
        const x_at_T = Y0 - T * Math.tan(theta);
        const isHitBackingBar = (x_at_T >= -12.5 && x_at_T <= 12.5);
        const effective_T = isHitBackingBar ? T + 9 : T;
        
        let d_display = 0; let isReflected = false; let skipText = "";
        if (d_calc <= effective_T) {
            d_display = d_calc; isReflected = false; 
            skipText = (isHitBackingBar && d_calc > T) ? "0.5 SKIP (è£å½“ã¦é‡‘ã¸é€é)" : "0.5 SKIP (ç›´å°„)";
        } else {
            d_display = effective_T - (d_calc - effective_T); isReflected = true; skipText = "1.0 SKIP (åå°„)";
        }

        document.getElementById('depth').value = d_display.toFixed(1);
        document.getElementById('distance').value = y_calc.toFixed(1);
        statusOverlay.innerText = skipText;
        renderPhysicsView(T, effective_T, theta, W, y_calc, d_display, isReflected, jointShape, Y0);
    }

    function renderPhysicsView(T, effective_T, theta, W, y, d, isReflected, jointShape, Y0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const scale = Math.min(6.0, 220 / T); 
        const centerY = canvas.height / 2; const startY = centerY - (T * scale) / 2; const weldCenterX = 250; 
        ctx.save();
        const plateWidth = 1000; const gap = 7 * scale; const backingHeight = 9 * scale; const backingWidth = 25 * scale; 
        
        ctx.fillStyle = "#333"; ctx.strokeStyle = "#888"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.rect(weldCenterX - gap/2 - plateWidth, startY, plateWidth, T * scale); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.rect(weldCenterX + gap/2, startY, plateWidth, T * scale); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "#222"; ctx.strokeStyle = "#666";
        ctx.beginPath(); ctx.rect(weldCenterX - backingWidth/2, startY + T*scale, backingWidth, backingHeight); ctx.fill(); ctx.stroke();
        const grooveAngle = 35 * (Math.PI / 180); const grooveTopWidth = (T * scale) * Math.tan(grooveAngle);
        ctx.fillStyle = "rgba(80, 80, 80, 0.8)"; ctx.beginPath(); ctx.moveTo(weldCenterX - gap/2, startY + T*scale); ctx.lineTo(weldCenterX + gap/2, startY + T*scale); 
        if (jointShape === 'single_bevel') { ctx.lineTo(weldCenterX + gap/2 + grooveTopWidth, startY); ctx.lineTo(weldCenterX - gap/2, startY); } else { ctx.lineTo(weldCenterX + gap/2 + grooveTopWidth, startY); ctx.lineTo(weldCenterX - gap/2 - grooveTopWidth, startY); }
        ctx.closePath(); ctx.fill(); ctx.stroke();
        
        const probeX = weldCenterX + Y0 * scale; 
        ctx.fillStyle = "#ccc"; ctx.fillRect(probeX - 20, startY - 25, 40, 25); ctx.strokeStyle = "#fff"; ctx.strokeRect(probeX - 20, startY - 25, 40, 25);
        ctx.beginPath(); ctx.strokeStyle = "#555"; ctx.lineWidth = 2; ctx.moveTo(probeX + 10, startY - 25); ctx.bezierCurveTo(probeX + 20, startY - 50, probeX + 40, startY - 10, probeX + 60, startY - 30); ctx.stroke();
        
        ctx.fillStyle = "#ff3e3e";
        ctx.beginPath();
        ctx.moveTo(probeX, startY); 
        ctx.lineTo(probeX - 6, startY - 10);
        ctx.lineTo(probeX + 6, startY - 10);
        ctx.fill();

        ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = "#00ff41"; ctx.moveTo(probeX, startY);
        let flawX, flawY;
        if (!isReflected) {
            const x_move = W * Math.sin(theta) * scale; const y_move = W * Math.cos(theta) * scale; flawX = probeX - x_move; flawY = startY + y_move; ctx.lineTo(flawX, flawY);
        } else {
            ctx.setLineDash([5, 5]); const x_to_bottom = effective_T * Math.tan(theta) * scale; const reflectX = probeX - x_to_bottom; const reflectY = startY + effective_T * scale; ctx.lineTo(reflectX, reflectY);
            const W_to_bottom = effective_T / Math.cos(theta); const W_remain = W - W_to_bottom; const x_move_2 = W_remain * Math.sin(theta) * scale; const y_move_2 = W_remain * Math.cos(theta) * scale; flawX = reflectX - x_move_2; flawY = reflectY - y_move_2; ctx.lineTo(flawX, flawY);
        }
        ctx.stroke(); ctx.setLineDash([]);
        ctx.beginPath(); ctx.arc(flawX, flawY, 5, 0, Math.PI * 2); ctx.fillStyle = "#ff3e3e"; ctx.fill(); ctx.strokeStyle = "#ff3e3e"; ctx.beginPath(); ctx.arc(flawX, flawY, 10, 0, Math.PI * 2); ctx.stroke();
        ctx.restore();
    }
    
    draw();
</script>
</body>
</html>